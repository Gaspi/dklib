#NAME dk_monads

istruetype : dk_bool.B -> cc.uT.
istrue : dk_bool.B -> Type := b : dk_bool.B => cc.eT (istruetype b).
I : istrue dk_bool.true.

equal : A : cc.uT -> cc.eT A -> cc.eT A -> dk_bool.B.
refl : A : cc.uT -> a : cc.eT A -> istrue (equal A a a).




(; Monadic operators ;)
return :
  M : (cc.uT -> cc.uT) ->
  A : cc.uT ->
  cc.eT A -> cc.eT (M A).

bind :
  M : (cc.uT -> cc.uT) ->
  A : cc.uT ->
  B : cc.uT ->
  cc.eT (M A) -> (cc.eT A -> cc.eT (M B)) -> cc.eT (M B).

seq :
  M : (cc.uT -> cc.uT) ->
  A : cc.uT ->
  B : cc.uT ->
  cc.eT (M A) ->
  cc.eT (M B) ->
  cc.eT (M B)
  :=
    M : (cc.uT -> cc.uT) =>
    A : cc.uT =>
    B : cc.uT =>
    ma : cc.eT (M A) =>
    mb : cc.eT (M B) =>
    bind M A B ma (a : cc.eT A => mb).

comp : 
  M : (cc.uT -> cc.uT) ->
  A : cc.uT ->
  B : cc.uT ->
  C : cc.uT ->
  f : (cc.eT A -> cc.eT (M B)) ->
  g : (cc.eT B -> cc.eT (M C)) ->
  x : cc.eT A ->
  cc.eT (M C)
  :=
    M : (cc.uT -> cc.uT) =>
    A : cc.uT =>
    B : cc.uT =>
    C : cc.uT =>
    f : (cc.eT A -> cc.eT (M B)) =>
    g : (cc.eT B -> cc.eT (M C)) =>
    x : cc.eT A =>
    bind M B C (f x) g.

(; monadic laws ;)

[ M : (cc.uT -> cc.uT) ,
  A : cc.uT ,
  B : cc.uT ,
  a : cc.eT A ,
  f : (cc.eT A -> cc.eT (M B)) ]
    bind M A B (return _ _ a) f --> f a.

[ M : (cc.uT -> cc.uT),
  A : cc.uT,
  m : cc.eT (M A) ]
    bind M _ _ m (return M A) --> m.

[ M : (cc.uT -> cc.uT),
  A : cc.uT,
  B : cc.uT,
  C : cc.uT,
  f : (cc.eT A -> cc.eT (M B)),
  g : (cc.eT B -> cc.eT (M C)),
  m : cc.eT (M A) ]
    bind M B C (bind _ A _ m f) g
      -->
    bind M A C m (comp M A B C f g).

(; option type ;)

option : cc.uT -> cc.uT.
None : A : cc.uT -> cc.eT (option A).
Some : A : cc.uT -> cc.eT A -> cc.eT (option A).

(; the option monad ;)

[] return option --> Some.

[A : cc.uT,
 B : cc.uT, f : cc.eT A -> cc.eT (option B)]
    bind option A B (None _) f --> None B
[A : cc.uT, a : cc.eT A,
 B : cc.uT, f : cc.eT A -> cc.eT (option B)]
    bind option A B (Some _ a) f --> f a.

(; list type ;)

list : cc.uT -> cc.uT.
Nil : A : cc.uT -> cc.eT (list A).
Cons : A : cc.uT -> cc.eT A -> cc.eT (list A) -> cc.eT (list A).

append : A : cc.uT -> cc.eT (list A) -> cc.eT (list A) -> cc.eT (list A).
[A : cc.uT, l2 : cc.eT (list A)]
    append A (Nil _) l2 --> l2
[A : cc.uT, a : cc.eT A, l1 : cc.eT (list A), l2 : cc.eT (list A)]
    append A (Cons _ a l1) l2 --> Cons A a (append A l1 l2)
(; Let's add a third rule to get append l Nil = l ;)
[A : cc.uT, l1 : cc.eT (list A)]
    append A l1 (Nil _) --> l1.

(; the list monad ;)

[] return list --> A : cc.uT => a : cc.eT A => Cons A a (Nil A).

[A : cc.uT,
 B : cc.uT, f : cc.eT A -> cc.eT (list B)]
    bind list A B (Nil _) f --> Nil B
[A : cc.uT, a : cc.eT A, l : cc.eT (list A),
 B : cc.uT, f : cc.eT A -> cc.eT (list B)]
    bind list A B (Cons _ a l) f --> append B (f a) (bind list A B l f).
