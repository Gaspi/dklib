#NAME dk_obj

(; TODO: eliminate dependencies on dk_lrecords and cc ;)
(; Have a version of bool independant of cc ;)

(; Labels ;)
Label := dk_lrecords.Label.
label_eq := dk_lrecords.label_eq.
if_label_eq := dk_lrecords.if_label_eq.
Domain := dk_lrecords.Domain.
domain_nil := dk_lrecords.domain_nil.
domain_cons := dk_lrecords.domain_cons.
domain_mem := dk_lrecords.domain_mem.

(; Booleans ;)
bool := dk_bool.bool.
Bool := dk_bool.B.
true : Bool := dk_bool.true.
false : Bool := dk_bool.false.
not : Bool -> Bool := dk_bool.not.
and : Bool -> Bool -> Bool
    := dk_bool.and.
or : Bool -> Bool -> Bool
    := dk_bool.or.
if : A : cc.uT ->
     Bool ->
     cc.eT A ->
     cc.eT A ->
     cc.eT A
   := dk_bool.ite.

if_dep : A : cc.uT ->
         B : cc.uT ->
         b : Bool ->
         cc.eT A ->
         cc.eT B ->
         cc.eT (if cc.uuT b A B).
[ A : cc.uT,
  B : cc.uT,
  a : cc.eT A ]
    if_dep A B true a _ --> a
[ A : cc.uT,
  B : cc.uT,
  b : cc.eT B ]
    if_dep A B false _ b --> b.

istrue : Bool -> cc.uT := dk_lrecords.istrue.
Istrue : Bool -> Type := dk_lrecords.Istrue.
tt : Istrue true := dk_logic.I.
fe : A : cc.uT -> Istrue false -> cc.eT A
   := dk_logic.False_elim.
or_elim : b1 : Bool ->
          b2 : Bool ->
          A : cc.uT ->
          Istrue (or b1 b2) ->
          (Istrue b1 -> cc.eT A) ->
          (Istrue b2 -> cc.eT A) ->
          cc.eT A
        :=
          dk_bool.match
            (b1 : Bool =>
             cc.Pi_TTT
               bool
               (b2 : Bool =>
                cc.Pi_TTT
                  cc.uuT
                  (A : cc.uT =>
                   cc.Arrow
                     (istrue (or b1 b2))
                     (cc.Arrow
                       (cc.Arrow (istrue b1) A)
                       (cc.Arrow
                         (cc.Arrow (istrue b2) A)
                         A)))))
            (b2 : Bool =>
             A : cc.uT =>
             I : Istrue true =>
             H1 : (Istrue true -> cc.eT A) =>
             H2 : (Istrue b2 -> cc.eT A) =>
             H1 I)
            (b2 : Bool =>
             A : cc.uT =>
             H : Istrue b2 =>
             H1 : (Istrue false -> cc.eT A) =>
             H2 : (Istrue b2 -> cc.eT A) =>
             H2 H).
and_elim1 := dk_logic.bool_and_elim1.
and_elim2 := dk_logic.bool_and_elim2.

(; Object types ;)
objType : cc.uT.
ObjType : Type := cc.eT objType.  (; ObjType := list (Label * ObjType) ;)
Ot_nil : ObjType.
Ot_cons : Label -> ObjType -> ObjType -> ObjType.

Ot_assoc : Label -> ObjType -> ObjType.
[ l1 : Label,
  l2 : Label,
  A : ObjType,
  B : ObjType]
    Ot_assoc l1 (Ot_cons l2 A B)
      -->
    if
      objType
      (label_eq l1 l2)
      A
        (Ot_assoc l1 B).

Ot_rassoc : ObjType -> Label -> ObjType
          :=
            A : ObjType =>
            l : Label =>
            Ot_assoc l A.

Ot_domain : ObjType -> Domain.
[] Ot_domain Ot_nil --> domain_nil
[ l : Label,
  A : ObjType ]
    Ot_domain (Ot_cons l _ A)
      -->
    domain_cons l (Ot_domain A).

Ot_eq : ObjType -> ObjType -> Bool.
[ A : ObjType ] Ot_eq A A --> true
[ l1 : Label,
  A1 : ObjType,
  B1 : ObjType,
  l2 : Label,
  A2 : ObjType,
  B2 : ObjType ]
    Ot_eq (Ot_cons l1 A1 B1)
          (Ot_cons l2 A2 B2)
      -->
    and
      (label_eq l1 l2)
      (and
        (Ot_eq A1 A2)
        (Ot_eq B1 B2))
[] Ot_eq Ot_nil (Ot_cons _ _ _) --> false
[] Ot_eq (Ot_cons _ _ _) Ot_nil --> false.

Ot_rm : Label -> ObjType -> ObjType -> ObjType.
[ l1 : Label,
  A1 : ObjType,
  l2 : Label,
  A2 : ObjType,
  B2 : ObjType]
    Ot_rm
      l1
      A1
      (Ot_cons l2 A2 B2)
      -->
    if
      objType
      (and (label_eq l1 l2) (Ot_eq A1 A2))
      B2
      (Ot_cons l2 A2 (Ot_rm l1 A1 B2)).

Ot_has_key : ObjType -> Label -> Bool.
[] Ot_has_key Ot_nil _ --> false
[ l1 : Label,
  A1 : ObjType,
  B : ObjType,
  l2 : Label ]
    Ot_has_key (Ot_cons l1 A1 B) l2
      -->
      or (label_eq l1 l2)
         (Ot_has_key B l2).

Ot_mem : Label -> ObjType -> ObjType -> Bool.

[] Ot_mem _ _ Ot_nil --> false
[ l1 : Label,
  A1 : ObjType,
  l2 : Label,
  A2 : ObjType,
  B2 : ObjType ]
    Ot_mem l1 A1 (Ot_cons l2 A2 B2)
      -->
    or
      (and
        (label_eq l1 l2)
        (Ot_eq A1 A2))
      (Ot_mem l1 A1 B2).

(; Ot_del l A B: Remove (l, A) from B if present. ;)
Ot_del : Label -> ObjType -> ObjType -> ObjType.
[] Ot_del _ _ Ot_nil --> Ot_nil
[ l1 : Label,
  A1 : ObjType,
  l2 : Label,
  A2 : ObjType,
  B : ObjType ]
    Ot_del l1 A1 (Ot_cons l2 A2 B)
      -->
    if
      objType
      (and (label_eq l1 l2) (Ot_eq A1 A2))
      B
      (Ot_cons l2 A2 (Ot_del l1 A1 B)).


(; Ot_mapassoc A [l_i : B_i] = [l_i : assoc l A] ;)
Ot_mapassoc : ObjType -> ObjType -> ObjType.
[] Ot_mapassoc _ Ot_nil --> Ot_nil
[ A : ObjType,
  l2 : Label,
  A2 : ObjType,
  B : ObjType ]
    Ot_mapassoc A (Ot_cons l2 A2 B)
      -->
    Ot_cons l2 (Ot_assoc l2 A) (Ot_mapassoc A B).

(; Ot_st A B := A <: B ;)
Ot_st : ObjType -> ObjType -> Bool.
[ A : ObjType ] Ot_st A A --> true
[] Ot_st _ Ot_nil --> true
[ B1 : ObjType,
  l2 : Label,
  A2 : ObjType,
  B2 : ObjType ]
    Ot_st B1 (Ot_cons l2 A2 B2)
      -->
    and
      (Ot_eq A2 (Ot_assoc l2 B1))
      (Ot_st B1 B2).

(; This strange rule is needed for subtyping. ;)
(; [ l : Label, ;)
(;   A : ObjType ] ;)
(;     Ot_assoc l (Ot_rm _ _ A) --> Ot_assoc l A. ;)

Ot_st_r : ObjType -> ObjType -> ObjType.
(; A <R B -->* B <=> A <: B ;)

Ot_st_l : ObjType -> ObjType -> ObjType.
(; A <L B -->* A <=> A <: B ;)

[] Ot_st_r Ot_nil Ot_nil --> Ot_nil
[ A : ObjType ]
    Ot_st_r (Ot_cons _ _ A) Ot_nil
      -->
    Ot_st_r A Ot_nil
[ A1 : ObjType,
  l2 : Label,
  A2 : ObjType,
  B2 : ObjType]
    Ot_st_r A1 (Ot_cons l2 A2 B2)
      -->
    Ot_cons l2 (Ot_assoc l2 A1)
            (Ot_st_r (Ot_rm l2 A2 A1) B2).

[] Ot_st_l Ot_nil Ot_nil --> Ot_nil
[ l1 : Label,
  A1 : ObjType,
  A : ObjType,
  A2 : ObjType ]
    Ot_st_l (Ot_cons l1 A1 A) A2
      -->
    Ot_cons l1 (Ot_assoc l1 A2)
               (Ot_st_l A
                  (Ot_del l1 A1 A2)).


(; Expressions, methods and objects ;)
expr : ObjType -> cc.uT.
Expr : ObjType -> Type.
[ A : ObjType ] Expr A --> cc.eT (expr A).
method : ObjType -> ObjType -> cc.uT.
[ A : ObjType,
  B : ObjType ]
    method A B --> cc.Arrow (expr A) (expr B).
Method : ObjType -> ObjType -> Type.
[ A : ObjType,
  B : ObjType ]
    Method A B --> cc.eT (method A B).
lmethod : Label -> ObjType -> cc.uT.
[ l : Label,
  A : ObjType ]
    lmethod l A
      -->
    method A (Ot_assoc l A).
Lmethod : Label -> ObjType -> Type.
[ l : Label,
  A : ObjType ]
    Lmethod l A
      -->
    Method A (Ot_assoc l A).

preObj : ObjType -> (Label -> ObjType) -> Domain -> cc.uT.
PreObj : ObjType -> (Label -> ObjType) -> Domain -> Type.
[ A : ObjType,
  B : Label -> ObjType,
  C : Domain ] PreObj A B C --> cc.eT (preObj A B C).
Po_nil : A : ObjType ->
         B : (Label -> ObjType) ->
         PreObj A B domain_nil.
Po_cons : A : ObjType ->
          B : (Label -> ObjType) ->
          C : Domain ->
          l : Label ->
          Method A (B l) ->
          PreObj A B C ->
          PreObj A B (domain_cons l C).

Obj : ObjType -> Type.
[ A : ObjType ]
    Obj A
      -->
    PreObj A (Ot_rassoc A) (Ot_domain A).

make : A : ObjType -> Obj A -> Expr A.

select : A : ObjType ->
         eA : Expr A ->
         l : Label ->
         Expr (Ot_assoc l A).
update : A : ObjType ->
         eA : Expr A ->
         l : Label ->
         m : Lmethod l A ->
         Expr A.

preselect : A : ObjType ->
            B : (Label -> ObjType) ->
            C : Domain ->
            o : PreObj A B C ->
            l : Label ->
            Method A (B l).
preupdate : A : ObjType ->
            B : (Label -> ObjType) ->
            C : Domain ->
            o : PreObj A B C ->
            l : Label ->
            Method A (B l) ->
            PreObj A B C.

[ A : ObjType,
  o : Obj A,
  l : Label ]
    select A (make _ o) l
      -->
    preselect
      A
      (Ot_rassoc A)
      (Ot_domain A)
      o
        l
        (make A o).

[ A : ObjType,
  B : Label -> ObjType,
  C : Domain,
  l1 : Label,
  m : Method A (B l1),
  o : PreObj A B C,
  l2 : Label ]
    preselect _ _ _ (Po_cons A B C l1 m o) l2
      -->
    if_label_eq
      (l : Label => method A (B l))
      l1
        l2
        m
        (preselect A B C o l2).

[A : ObjType,
 o : Obj A,
 l : Label,
 m : Lmethod l A]
    update A (make _ o) l m
      -->
    make
      A
      (preupdate
        A
        (Ot_rassoc A)
        (Ot_domain A)
        o
          l
          m).

[ A : ObjType,
  B : Label -> ObjType,
  C : Domain,
  l1 : Label,
  m1 : Method A (B l1),
  o : PreObj A B C,
  l2 : Label,
  m2 : Method A (B l2) ]
    preupdate _ _ _ (Po_cons A B C l1 m1 o) l2 m2
      -->
    if_label_eq
      (l : Label => preObj A B (domain_cons l C))
      l2
        l1
        (Po_cons A B C l2 m2 o)
        (Po_cons A B C l1 m1 (preupdate A B C o l2 m2)).


(; Subtyping ;)

precast : A : ObjType ->
          B : ObjType ->
          Expr A ->
          C : Domain ->
          PreObj B (Ot_rassoc A) C.

ocast : A : ObjType ->
        B : ObjType ->
        Expr A ->
        PreObj B (Ot_rassoc A) (Ot_domain B)
      :=
        A : ObjType =>
        B : ObjType =>
        o : Expr A =>
        precast A B o (Ot_domain B).

[ A : ObjType,
  B : ObjType,
  o : Expr A ]
    precast A B o (dk_list.nil _)
      -->
    Po_nil B (Ot_rassoc A).

[ A : ObjType,
  B : ObjType,
  o : Expr A,
  l2 : Label,
  C : Domain ]
    precast A B o (dk_list.cons _ l2 C)
      -->
    Po_cons B (Ot_rassoc A) C l2
                (self : Expr B => select A o l2)
                (precast A B o C).

Ot_if_diff : b : Bool ->
             Istrue (not b) ->
             A : ObjType ->
             B : ObjType ->
             Istrue (Ot_eq (if objType b A B) B).
[ A : ObjType, B : ObjType ] Ot_if_diff false _ A B --> tt.

assoc_cons_diff : l1 : Label ->
                  l2 : Label ->
                  A : ObjType ->
                  B : ObjType ->
                  Istrue (not (label_eq l1 l2)) ->
                  Istrue (Ot_eq (Ot_assoc l1 (Ot_cons l2 A B))
                                (Ot_assoc l1 B)).

[ l1 : Label,
  l2 : Label,
  A : ObjType,
  B : ObjType,
  H : Istrue (not (label_eq l1 l2)) ]
    assoc_cons_diff l1 l2 A B H
      -->
    Ot_if_diff
      (label_eq l1 l2)
      H
      A
      (Ot_assoc l1 B).

Ot_eq_trans : A : ObjType ->
              B : ObjType ->
              C : ObjType ->
              Istrue (Ot_eq A B) ->
              Istrue (Ot_eq B C) ->
              Istrue (Ot_eq A C).

assoc_subtype : A : ObjType ->
                B : ObjType ->
                l : Label ->
                Istrue (Ot_st A B) ->
                Istrue (Ot_has_key B l) ->
                Istrue (Ot_eq (Ot_assoc l B)
                              (Ot_assoc l A)).

[ A : ObjType,
  l : Label,
  refl : Istrue true ]
    assoc_subtype A A l refl _ --> tt

[ A : ObjType,
  l : Label,
  f : Istrue false ]
    assoc_subtype A Ot_nil l _ f
      -->
    fe (istrue (Ot_eq (Ot_assoc l Ot_nil)
                      (Ot_assoc l A)))
       f.


[ l2 : Label,
  A2 : ObjType,
  B2 : ObjType,
  l1 : Label,
  B1 : ObjType,
  st : Istrue (and (Ot_eq A2 (Ot_assoc l2 B1)) (Ot_st B1 B2)),
  hk : Istrue (or (label_eq l2 l1) (Ot_has_key B2 l1))]
    assoc_subtype B1 (Ot_cons l2 A2 B2) l1 st hk
      -->
    if_label_eq
      (l : Label => istrue (Ot_eq (Ot_assoc l (Ot_cons l2 A2 B2))
                                  (Ot_assoc l B1)))
      l2 l1
        (and_elim1
          (Ot_eq A2 (Ot_assoc l2 B1))
          (Ot_st B1 B2)
          st)
        (Ot_eq_trans
          (Ot_assoc l1 (Ot_cons l2 A2 B2))
          (Ot_assoc l1 B2)
          (Ot_assoc l1 B1)
          (assoc_cons_diff l1 l2 A2 B2 (dk_fail.fail (istrue (not (label_eq l1 l2)))))
          (assoc_subtype
            B1
            B2
            l1
            (and_elim2
              (Ot_eq A2 (Ot_assoc l2 B1))
              (Ot_st B1 B2)
              st)
            (or_elim
              (label_eq l2 l1)
              (Ot_has_key B2 l1)
              (istrue (Ot_has_key B2 l1))
              hk
                (H : Istrue (label_eq l2 l1) => dk_fail.fail (istrue (Ot_has_key B2 l1)))
                (H : Istrue (Ot_has_key B2 l1) => H)))).

Ot_eq_expr : A : ObjType ->
             B : ObjType ->
             Istrue (Ot_eq A B) ->
             Expr A ->
             Expr B.
[ A : ObjType, o : Expr A ] Ot_eq_expr A A tt o --> o.

meth_eq : A : ObjType ->
          B1 : ObjType ->
          B2 : ObjType ->
          Istrue (Ot_eq B2 B1) ->
          Method A B1 ->
          Method A B2.

[ A : ObjType,
  B : ObjType,
  m : Method A B ] meth_eq A B B _ m --> m.

Ot_eq_po : A : ObjType ->
           B1 : ObjType ->
           B2 : ObjType ->
           C : Domain ->
           (l : Label ->
            Istrue (domain_mem l C) ->
            Istrue (Ot_eq (Ot_assoc l B2) (Ot_assoc l B1))) ->
           PreObj A (Ot_rassoc B1) C ->
           PreObj A (Ot_rassoc B2) C.

[ A : ObjType,
  B1 : ObjType,
  B2 : ObjType,
  o : PreObj A (Ot_rassoc B1) domain_nil]
    Ot_eq_po A B1 B2 _ _ (Po_nil _ _)
      -->
    Po_nil A (Ot_rassoc B2).

[ A : ObjType,
  B1 : ObjType,
  B2 : ObjType,
  C : Domain,
  l : Label,
  m : Method A (Ot_assoc l B1),
  H : l2 : Label ->
      Istrue (domain_mem l2 (domain_cons l C)) ->
      Istrue (Ot_eq (Ot_assoc l2 B2) (Ot_assoc l2 B1)), 
  o : PreObj A (Ot_rassoc B1) C]
    Ot_eq_po A B1 B2 (dk_list.cons _ l C) H (Po_cons _ _ _ _ m o)
      -->
    Po_cons
      A
      (Ot_rassoc B2)
      C
        l
        (meth_eq A (Ot_assoc l B1) (Ot_assoc l B2) (H l tt) m)
        (Ot_eq_po A B1 B2 C
                       (l2 : Label =>
                        if_label_eq
                          (l3 : Label =>
                           cc.Arrow
                             (istrue (domain_mem l3 C))
                             (istrue (Ot_eq (Ot_assoc l3 B2) (Ot_assoc l3 B1))))
                          l
                            l2
                            (t : Istrue (domain_mem l C) => H l tt)
                            (t : Istrue (domain_mem l2 C) =>
                             H
                               l2
                               (dk_fail.fail
                                 (istrue (dk_lrecords.domain_mem l2 (domain_cons l C))))))
                       o).


Po_cons_init : A : ObjType ->
               C : Domain ->
               l : Label ->
               PreObj A (Ot_rassoc A) C ->
               PreObj A (Ot_rassoc A) (domain_cons l C)
             :=
               A : ObjType =>
               C : Domain =>
               l : Label =>
               Po_cons A (Ot_rassoc A) C l (self : Expr A => select A self l).

preinit : A : ObjType ->
          C : Domain ->
          PreObj A (Ot_rassoc A) C.

[ A : ObjType ]
    preinit A (dk_list.nil _)
      -->
    Po_nil A (Ot_rassoc A).


[ A : ObjType,
  l : Label,
  C : Domain ]
    preinit A (dk_list.cons _ l C)
      -->
    Po_cons_init A C l (preinit A C).

init : A : ObjType -> Expr A
     := A : ObjType =>
        make A (preinit A (Ot_domain A)).

