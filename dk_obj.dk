#NAME dk_obj

(; Labels ;)
Label := dk_lrecords.Label.
label_eq := dk_lrecords.label_eq.
if_label_eq := dk_lrecords.if_label_eq.
Domain := dk_lrecords.Domain.
domain_nil := dk_lrecords.domain_nil.
domain_cons := dk_lrecords.domain_cons.

(; Booleans ;)
bool := dk_bool.bool.
Bool := dk_bool.B.
true : Bool := dk_bool.true.
false : Bool := dk_bool.false.
not : Bool -> Bool := dk_bool.not.
and : Bool -> Bool -> Bool
    := dk_bool.and.
or : Bool -> Bool -> Bool
    := dk_bool.or.
if : A : cc.uT ->
     Bool ->
     cc.eT A ->
     cc.eT A ->
     cc.eT A
   := dk_bool.ite.

if_dep : A : cc.uT ->
         B : cc.uT ->
         b : Bool ->
         cc.eT A ->
         cc.eT B ->
         cc.eT (if cc.uuT b A B).
[ A : cc.uT,
  B : cc.uT,
  a : cc.eT A ]
    if_dep A B true a _ --> a
[ A : cc.uT,
  B : cc.uT,
  b : cc.eT B ]
    if_dep A B false _ b --> b.

istrue : Bool -> cc.uT := dk_lrecords.istrue.
Istrue : Bool -> Type := dk_lrecords.Istrue.
tt : Istrue true := dk_logic.I.
fe : A : cc.uT -> Istrue false -> cc.eT A
   := dk_logic.False_elim.
or_elim : b1 : Bool ->
          b2 : Bool ->
          A : cc.uT ->
          Istrue (or b1 b2) ->
          (Istrue b1 -> cc.eT A) ->
          (Istrue b2 -> cc.eT A) ->
          cc.eT A
        :=
          dk_bool.match
            (b1 : Bool =>
             cc.Pi_TTT
               bool
               (b2 : Bool =>
                cc.Pi_TTT
                  cc.uuT
                  (A : cc.uT =>
                   cc.Arrow
                     (istrue (or b1 b2))
                     (cc.Arrow
                       (cc.Arrow (istrue b1) A)
                       (cc.Arrow
                         (cc.Arrow (istrue b2) A)
                         A)))))
            (b2 : Bool =>
             A : cc.uT =>
             I : Istrue true =>
             H1 : (Istrue true -> cc.eT A) =>
             H2 : (Istrue b2 -> cc.eT A) =>
             H1 I)
            (b2 : Bool =>
             A : cc.uT =>
             H : Istrue b2 =>
             H1 : (Istrue false -> cc.eT A) =>
             H2 : (Istrue b2 -> cc.eT A) =>
             H2 H).
and_elim1 := dk_logic.bool_and_elim1.
and_elim2 := dk_logic.bool_and_elim2.

(; Object types ;)
objType : cc.uT.
ObjType : Type := cc.eT objType.  (; ObjType := list (Label * ObjType) ;)
Ot_nil : ObjType.
Ot_cons : Label -> ObjType -> ObjType -> ObjType.

Ot_assoc : Label -> ObjType -> ObjType.
[ l1 : Label,
  l2 : Label,
  A : ObjType,
  B : ObjType]
    Ot_assoc l1 (Ot_cons l2 A B)
      -->
    if
      objType
      (label_eq l1 l2)
      A
        (Ot_assoc l1 B).

Ot_rassoc : ObjType -> Label -> ObjType
          :=
            A : ObjType =>
            l : Label =>
            Ot_assoc l A.

Ot_domain : ObjType -> Domain.
[] Ot_domain Ot_nil --> domain_nil
[ l : Label,
  A : ObjType ]
    Ot_domain (Ot_cons l _ A)
      -->
    domain_cons l (Ot_domain A).

Ot_eq : ObjType -> ObjType -> Bool.
[ A : ObjType ] Ot_eq A A --> true
[ l1 : Label,
  A1 : ObjType,
  B1 : ObjType,
  l2 : Label,
  A2 : ObjType,
  B2 : ObjType ]
    Ot_eq (Ot_cons l1 A1 B1)
          (Ot_cons l2 A2 B2)
      -->
    and
      (label_eq l1 l2)
      (and
        (Ot_eq A1 A2)
        (Ot_eq B1 B2))
[] Ot_eq Ot_nil (Ot_cons _ _ _) --> false
[] Ot_eq (Ot_cons _ _ _) Ot_nil --> false.

Ot_rm : Label -> ObjType -> ObjType -> ObjType.
[ l1 : Label,
  A1 : ObjType,
  l2 : Label,
  A2 : ObjType,
  B2 : ObjType]
    Ot_rm
      l1
      A1
      (Ot_cons l2 A2 B2)
      -->
    if
      objType
      (and (label_eq l1 l2) (Ot_eq A1 A2))
      B2
      (Ot_cons l2 A2 (Ot_rm l1 A1 B2)).

Ot_has_key : ObjType -> Label -> Bool.
[] Ot_has_key Ot_nil _ --> false
[ l1 : Label,
  A1 : ObjType,
  B : ObjType,
  l2 : Label ]
    Ot_has_key (Ot_cons l1 A1 B) l2
      -->
      or (label_eq l1 l2)
         (Ot_has_key B l2).

Ot_mem : Label -> ObjType -> ObjType -> Bool.

[] Ot_mem _ _ Ot_nil --> false
[ l1 : Label,
  A1 : ObjType,
  l2 : Label,
  A2 : ObjType,
  B2 : ObjType ]
    Ot_mem l1 A1 (Ot_cons l2 A2 B2)
      -->
    or
      (and
        (label_eq l1 l2)
        (Ot_eq A1 A2))
      (Ot_mem l1 A1 B2).

(; Ot_del l A B: Remove (l, A) from B if present. ;)
Ot_del : Label -> ObjType -> ObjType -> ObjType.
[] Ot_del _ _ Ot_nil --> Ot_nil
[ l1 : Label,
  A1 : ObjType,
  l2 : Label,
  A2 : ObjType,
  B : ObjType ]
    Ot_del l1 A1 (Ot_cons l2 A2 B)
      -->
    if
      objType
      (and (label_eq l1 l2) (Ot_eq A1 A2))
      B
      (Ot_cons l2 A2 (Ot_del l1 A1 B)).


(; Ot_mapassoc A [l_i : B_i] = [l_i : assoc l A] ;)
Ot_mapassoc : ObjType -> ObjType -> ObjType.
[] Ot_mapassoc _ Ot_nil --> Ot_nil
[ A : ObjType,
  l2 : Label,
  A2 : ObjType,
  B : ObjType ]
    Ot_mapassoc A (Ot_cons l2 A2 B)
      -->
    Ot_cons l2 (Ot_assoc l2 A) (Ot_mapassoc A B).

(; Ot_st A B := A <: B ;)
Ot_st : ObjType -> ObjType -> Bool.
[ A : ObjType ] Ot_st A A --> true
[] Ot_st _ Ot_nil --> true
[ B1 : ObjType,
  l2 : Label,
  A2 : ObjType,
  B2 : ObjType ]
    Ot_st B1 (Ot_cons l2 A2 B2)
      -->
    and
      (Ot_eq A2 (Ot_assoc l2 B1))
      (Ot_st B1 B2).

(; This strange rule is needed for subtyping. ;)
(; [ l : Label, ;)
(;   A : ObjType ] ;)
(;     Ot_assoc l (Ot_rm _ _ A) --> Ot_assoc l A. ;)

Ot_st_r : ObjType -> ObjType -> ObjType.
(; A <R B -->* B <=> A <: B ;)

Ot_st_l : ObjType -> ObjType -> ObjType.
(; A <L B -->* A <=> A <: B ;)

[] Ot_st_r Ot_nil Ot_nil --> Ot_nil
[ A : ObjType ]
    Ot_st_r (Ot_cons _ _ A) Ot_nil
      -->
    Ot_st_r A Ot_nil
[ A1 : ObjType,
  l2 : Label,
  A2 : ObjType,
  B2 : ObjType]
    Ot_st_r A1 (Ot_cons l2 A2 B2)
      -->
    Ot_cons l2 (Ot_assoc l2 A1)
            (Ot_st_r (Ot_rm l2 A2 A1) B2).

[] Ot_st_l Ot_nil Ot_nil --> Ot_nil
[ l1 : Label,
  A1 : ObjType,
  A : ObjType,
  A2 : ObjType ]
    Ot_st_l (Ot_cons l1 A1 A) A2
      -->
    Ot_cons l1 (Ot_assoc l1 A2)
               (Ot_st_l A
                  (Ot_del l1 A1 A2)).


(; Expressions, methods and objects ;)
expr : ObjType -> cc.uT.
Expr : ObjType -> Type.
[ A : ObjType ] Expr A --> cc.eT (expr A).
method : ObjType -> ObjType -> cc.uT.
[ A : ObjType,
  B : ObjType ]
    method A B --> cc.Arrow (expr A) (expr B).
Method : ObjType -> ObjType -> Type.
[ A : ObjType,
  B : ObjType ]
    Method A B --> cc.eT (method A B).
lmethod : Label -> ObjType -> cc.uT.
[ l : Label,
  A : ObjType ]
    lmethod l A
      -->
    method A (Ot_assoc l A).
Lmethod : Label -> ObjType -> Type.
[ l : Label,
  A : ObjType ]
    Lmethod l A
      -->
    Method A (Ot_assoc l A).

preObj : ObjType -> (Label -> ObjType) -> Domain -> cc.uT.
PreObj : ObjType -> (Label -> ObjType) -> Domain -> Type.
[ A : ObjType,
  B : Label -> ObjType,
  C : Domain ] PreObj A B C --> cc.eT (preObj A B C).
Po_nil : A : ObjType ->
         B : (Label -> ObjType) ->
         PreObj A B domain_nil.
Po_cons : A : ObjType ->
          B : (Label -> ObjType) ->
          C : Domain ->
          l : Label ->
          Method A (B l) ->
          PreObj A B C ->
          PreObj A B (domain_cons l C).

Obj : ObjType -> Type.
[ A : ObjType ]
    Obj A
      -->
    PreObj A (Ot_rassoc A) (Ot_domain A).

make : A : ObjType -> Obj A -> Expr A.

select : A : ObjType ->
         eA : Expr A ->
         l : Label ->
         Expr (Ot_assoc l A).
update : A : ObjType ->
         eA : Expr A ->
         l : Label ->
         m : Lmethod l A ->
         Expr A.

preselect : A : ObjType ->
            B : (Label -> ObjType) ->
            C : Domain ->
            o : PreObj A B C ->
            l : Label ->
            Method A (B l).
preupdate : A : ObjType ->
            B : (Label -> ObjType) ->
            C : Domain ->
            o : PreObj A B C ->
            l : Label ->
            Method A (B l) ->
            PreObj A B C.

[ A : ObjType,
  o : Obj A,
  l : Label ]
    select A (make _ o) l
      -->
    preselect
      A
      (Ot_rassoc A)
      (Ot_domain A)
      o
        l
        (make A o).

[ A : ObjType,
  B : Label -> ObjType,
  C : Domain,
  l1 : Label,
  m : Method A (B l1),
  o : PreObj A B C,
  l2 : Label ]
    preselect _ _ _ (Po_cons A B C l1 m o) l2
      -->
    if_label_eq
      (l : Label => method A (B l))
      l1
        l2
        m
        (preselect A B C o l2).

[A : ObjType,
 o : Obj A,
 l : Label,
 m : Lmethod l A]
    update A (make _ o) l m
      -->
    make
      A
      (preupdate
        A
        (Ot_rassoc A)
        (Ot_domain A)
        o
          l
          m).

[ A : ObjType,
  B : Label -> ObjType,
  C : Domain,
  l1 : Label,
  m1 : Method A (B l1),
  o : PreObj A B C,
  l2 : Label,
  m2 : Method A (B l2) ]
    preupdate _ _ _ (Po_cons A B C l1 m1 o) l2 m2
      -->
    if_label_eq
      (l : Label => preObj A B (domain_cons l C))
      l2
        l1
        (Po_cons A B C l2 m2 o)
        (Po_cons A B C l1 m1 (preupdate A B C o l2 m2)).

(; Example : booleans ;)

l_if : Label
:=
  dk_string.cons dk_char.i (
  dk_string.cons dk_char.f (
  dk_string.nil)).

l_then : Label
:=
  dk_string.cons dk_char.t (
  dk_string.cons dk_char.h (
  dk_string.cons dk_char.e (
  dk_string.cons dk_char.n (
  dk_string.nil)))).

l_else : Label
:=
  dk_string.cons dk_char.e (
  dk_string.cons dk_char.l (
  dk_string.cons dk_char.s (
  dk_string.cons dk_char.e (
  dk_string.nil)))).

boolT : A : ObjType ->
        ObjType
:=
  A : ObjType =>
  Ot_cons l_if A (
  Ot_cons l_then A (
  Ot_cons l_else A
  Ot_nil)).

BoolT : A : ObjType -> Type.
[ A : ObjType ] BoolT A --> Expr (boolT A).

trueT : A : ObjType -> BoolT A
      := A : ObjType =>
         make (boolT A)
              (Po_cons
                (boolT A)
                (Ot_rassoc (boolT A))
                (domain_cons l_then (domain_cons l_else domain_nil))
                l_if
                  (self : BoolT A =>
                   select (boolT A)
                          self l_then)
                  (Po_cons
                    (boolT A)
                    (Ot_rassoc (boolT A))
                    (domain_cons l_else domain_nil)
                    l_then
                      (self : BoolT A =>
                       select (boolT A)
                              self l_then)
                      (Po_cons
                        (boolT A)
                        (Ot_rassoc (boolT A))
                        domain_nil
                          l_else
                          (self : BoolT A =>
                           select (boolT A)
                                  self l_else)
                          (Po_nil (boolT A) (Ot_rassoc (boolT A)))))).

falseT : A : ObjType -> BoolT A
       := A : ObjType =>
          make (boolT A)
               (Po_cons
                 (boolT A)
                 (Ot_rassoc (boolT A))
                 (domain_cons l_then (domain_cons l_else domain_nil))
                 l_if
                   (self : BoolT A =>
                    select (boolT A)
                           self l_else)
                   (Po_cons
                     (boolT A)
                     (Ot_rassoc (boolT A))
                     (domain_cons l_else domain_nil)
                     l_then
                       (self : BoolT A =>
                        select (boolT A)
                               self l_then)
                       (Po_cons
                         (boolT A)
                         (Ot_rassoc (boolT A))
                         domain_nil
                           l_else
                           (self : BoolT A =>
                            select (boolT A)
                                   self l_else)
                           (Po_nil (boolT A) (Ot_rassoc (boolT A)))))).

ifT : A : ObjType ->
      BoolT A ->
      Expr A ->
      Expr A ->
      Expr A
    :=
      A : ObjType =>
      b : BoolT A =>
      then : Expr A =>
      else : Expr A =>
      select (boolT A)
             (update (boolT A)
                     (update (boolT A)
                             b
                               l_then
                               (self : BoolT A => then))
                     l_else
                       (self : BoolT A => else))
             l_if.

test1 :=
  A : ObjType =>
  t : Expr A =>
  e : Expr A =>
  ifT A (trueT A) t e.

test2 :=
  A : ObjType =>
  t : Expr A =>
  e : Expr A =>
  ifT A (falseT A) t e.

(; Subtyping ;)

precast : A : ObjType ->
          B : ObjType ->
          Expr A ->
          C : Domain ->
          PreObj B (Ot_rassoc A) C.

ocast : A : ObjType ->
        B : ObjType ->
        Expr A ->
        PreObj B (Ot_rassoc A) (Ot_domain B)
      :=
        A : ObjType =>
        B : ObjType =>
        o : Expr A =>
        precast A B o (Ot_domain B).

[ A : ObjType,
  B : ObjType,
  o : Expr A ]
    precast A B o (dk_list.nil _)
      -->
    Po_nil B (Ot_rassoc A).

[ A : ObjType,
  B : ObjType,
  o : Expr A,
  l2 : Label,
  C : Domain ]
    precast A B o (dk_list.cons _ l2 C)
      -->
    Po_cons B (Ot_rassoc A) C l2
                (self : Expr B => select A o l2)
                (precast A B o C).

Ot_if_diff : b : Bool ->
             Istrue (not b) ->
             A : ObjType ->
             B : ObjType ->
             Istrue (Ot_eq (if objType b A B) B).
[ A : ObjType, B : ObjType ] Ot_if_diff false _ A B --> tt.

assoc_cons_diff : l1 : Label ->
                  l2 : Label ->
                  A : ObjType ->
                  B : ObjType ->
                  Istrue (not (label_eq l1 l2)) ->
                  Istrue (Ot_eq (Ot_assoc l1 (Ot_cons l2 A B))
                                (Ot_assoc l1 B)).

[ l1 : Label,
  l2 : Label,
  A : ObjType,
  B : ObjType,
  H : Istrue (not (label_eq l1 l2)) ]
    assoc_cons_diff l1 l2 A B H
      -->
    Ot_if_diff
      (label_eq l1 l2)
      H
      A
      (Ot_assoc l1 B).

Ot_eq_trans : A : ObjType ->
              B : ObjType ->
              C : ObjType ->
              Istrue (Ot_eq A B) ->
              Istrue (Ot_eq B C) ->
              Istrue (Ot_eq A C).

assoc_subtype : A : ObjType ->
                B : ObjType ->
                l : Label ->
                Istrue (Ot_st A B) ->
                Istrue (Ot_has_key B l) ->
                Istrue (Ot_eq (Ot_assoc l B)
                              (Ot_assoc l A)).

[ A : ObjType,
  l : Label,
  refl : Istrue true ]
    assoc_subtype A A l refl _ --> tt

[ A : ObjType,
  l : Label,
  f : Istrue false ]
    assoc_subtype A Ot_nil l _ f
      -->
    fe (istrue (Ot_eq (Ot_assoc l Ot_nil)
                      (Ot_assoc l A)))
       f.


[ l2 : Label,
  A2 : ObjType,
  B2 : ObjType,
  l1 : Label,
  B1 : ObjType,
  st : Istrue (and (Ot_eq A2 (Ot_assoc l2 B1)) (Ot_st B1 B2)),
  hk : Istrue (or (label_eq l2 l1) (Ot_has_key B2 l1))]
    assoc_subtype B1 (Ot_cons l2 A2 B2) l1 st hk
      -->
    if_label_eq
      (l : Label => istrue (Ot_eq (Ot_assoc l (Ot_cons l2 A2 B2))
                                  (Ot_assoc l B1)))
      l2 l1
        (and_elim1
          (Ot_eq A2 (Ot_assoc l2 B1))
          (Ot_st B1 B2)
          st)
        (Ot_eq_trans
          (Ot_assoc l1 (Ot_cons l2 A2 B2))
          (Ot_assoc l1 B2)
          (Ot_assoc l1 B1)
          (assoc_cons_diff l1 l2 A2 B2 (dk_fail.fail (istrue (not (label_eq l1 l2)))))
          (assoc_subtype
            B1
            B2
            l1
            (and_elim2
              (Ot_eq A2 (Ot_assoc l2 B1))
              (Ot_st B1 B2)
              st)
            (or_elim
              (label_eq l2 l1)
              (Ot_has_key B2 l1)
              (istrue (Ot_has_key B2 l1))
              hk
                (H : Istrue (label_eq l2 l1) => dk_fail.fail (istrue (Ot_has_key B2 l1)))
                (H : Istrue (Ot_has_key B2 l1) => H)))).

Ot_eq_expr : A : ObjType ->
             B : ObjType ->
             Istrue (Ot_eq A B) ->
             Expr A ->
             Expr B.
[ A : ObjType, o : Expr A ] Ot_eq_expr A A tt o --> o.

Ot_eq_po : A : ObjType ->
           B : ObjType ->
           (l : Label ->
            Istrue (Ot_has_key B l) ->
            Istrue (Ot_eq (Ot_assoc l B) (Ot_assoc l A))) ->
           PreObj B (Ot_rassoc A) (Ot_domain B) ->
           Expr B.

(; Subtyping example ;)

l_get := dk_string.cons dk_char.g (
         dk_string.cons dk_char.e (
         dk_string.cons dk_char.t (
         dk_string.nil))).

l_set := dk_string.cons dk_char.s (
         dk_string.cons dk_char.e (
         dk_string.cons dk_char.t (
         dk_string.nil))).

l_contents := dk_string.cons dk_char.c (
              dk_string.cons dk_char.o (
              dk_string.cons dk_char.n (
              dk_string.cons dk_char.t (
              dk_string.cons dk_char.e (
              dk_string.cons dk_char.n (
              dk_string.cons dk_char.t (
              dk_string.cons dk_char.s (
              dk_string.nil)))))))).

Nat : ObjType.
Arrow : ObjType -> ObjType -> ObjType.

romCell : ObjType := Ot_cons l_get Nat Ot_nil.

promCell : ObjType
         :=
           Ot_cons l_get Nat (
           Ot_cons l_set (Arrow Nat romCell)
           Ot_nil).

privateCell : ObjType
            :=
              Ot_cons l_get Nat (
              Ot_cons l_set (Arrow Nat romCell) (
              Ot_cons l_contents Nat
              Ot_nil)).

Private_to_Prom : Expr privateCell -> Expr promCell
                := cell : Expr privateCell =>
                   Ot_eq_po
                     privateCell
                     promCell
                     (l : Label =>
                      assoc_subtype privateCell promCell l tt)
                     (ocast privateCell promCell cell).

Prom_to_Rom : Expr promCell -> Expr romCell
            := cell : Expr promCell =>
               Ot_eq_po
                 promCell
                 romCell
                 (l : Label =>
                  assoc_subtype promCell romCell l tt)
                 (ocast promCell romCell cell).

42 : Expr Nat.
24 : Expr Nat.

[ A : ObjType, B : ObjType ]
    expr (Arrow A B)
      -->
    cc.Arrow (expr A) (expr B).


myRom : Expr romCell
      :=
        (make romCell
           (Po_cons
             romCell
             (Ot_rassoc romCell)
             domain_nil
               l_get
               (self : Expr romCell => 42)
               (Po_nil romCell (Ot_rassoc romCell)))).

(; select romCell myRom l_get ;)

myProm : Expr promCell
      :=
        (make promCell
           (Po_cons
             promCell
             (Ot_rassoc promCell)
             (domain_cons l_set domain_nil)
               l_get
                 (self : Expr promCell => 42)
                 (Po_cons
                   promCell
                   (Ot_rassoc promCell)
                   domain_nil
                     l_set
                     (self : Expr promCell =>
                      x : Expr Nat =>
                      Prom_to_Rom
                        (update
                          promCell
                          self
                          l_get
                          (s : Expr promCell => x)))
                     (Po_nil promCell (Ot_rassoc promCell))))).

(; select promCell myProm l_get ;)
(; select romCell (select promCell myProm l_set 24) l_get ;)
(; select romCell (Ot_eq_po promCell romCell (l:Label => assoc_subtype promCell romCell l tt) (Po_cons romCell (Ot_rassoc promCell) (Ot_domain Ot_nil) l_get (self:(Expr romCell) => select promCell (update promCell (make promCell (Po_cons promCell (Ot_rassoc promCell) (domain_cons l_set domain_nil) l_get (self:(Expr promCell) => 42) (Po_cons promCell (Ot_rassoc promCell) domain_nil l_set (self:(Expr promCell) => x:(Expr Nat) => Prom_to_Rom (update promCell self l_get (s:(Expr promCell) => x))) (Po_nil promCell (Ot_rassoc promCell))))) l_get (s:(Expr promCell) => 24)) l_get) (precast promCell romCell (update promCell (make promCell (Po_cons promCell (Ot_rassoc promCell) (domain_cons l_set domain_nil) l_get (self:(Expr promCell) => 42) (Po_cons promCell (Ot_rassoc promCell) domain_nil l_set (self:(Expr promCell) => x:(Expr Nat) => Prom_to_Rom (update promCell self l_get (s:(Expr promCell) => x))) (Po_nil promCell (Ot_rassoc promCell))))) l_get (s:(Expr promCell) => 24)) (Ot_domain Ot_nil)))) l_get ;)

(; myCell : Expr promCell ;)
(;        := ;)
(;          Private_to_Prom ;)
(;            (make privateCell ;)
(;               (Po_cons ;)
(;                 privateCell ;)
(;                 (Ot_rassoc privateCell) ;)
(;                 (domain_cons l_set domain_nil) ;)
(;                 l_get ;)
(;                   (self : Expr privateCell => 42) ;)
(;                   (Po_cons ;)
(;                     privateCell ;)
(;                     (Ot_rassoc privateCell) ;)
(;                     domain_nil ;)
(;                       l_set ;)
(;                       (self : Expr privateCell => ;)
(;                        x : Expr Nat => ;)
(;                        (Prom_to_Rom ;)
(;                          (Private_to_Prom ;)
(;                            (update ;)
(;                              privateCell ;)
(;                              self ;)
(;                              l_get ;)
(;                              (s : Expr privateCell => ;)
(;                               x)))))))). ;)