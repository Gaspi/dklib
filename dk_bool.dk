#NAME dk_bool

(; B ;)
(; Declaration ;)
bool : cc.uT.
B : Type := cc.eT bool.
Bool := B.
(; Constructors ;)
true : B.
false : B.

(; Pattern-matching ;)
match :
  P : (B -> cc.uT) ->
  cc.eT (P true) ->
  cc.eT (P false) ->
  b : B ->
  cc.eT (P b).
[P : B -> cc.uT,
 Ht : cc.eT (P true),
 Hf : cc.eT (P false) ]
    match P Ht Hf true --> Ht
[P : B -> cc.uT,
 Ht : cc.eT (P true),
 Hf : cc.eT (P false) ]
    match P Ht Hf false --> Hf.

(; Operations ;)
(; polymorphic if .. then .. else .. ;)
ite :
  A : cc.uT ->
  B ->
  cc.eT A ->
  cc.eT A ->
  cc.eT A
:=
  A : cc.uT =>
  b : B =>
  x : cc.eT A =>
  y : cc.eT A =>
  match (b : B => A) x y b.

(; boolean if .. then .. else .. ;)
iteb : B -> B -> B -> B := ite bool.

(; negation ;)
not : B -> B := b : B => iteb b false true.

(; binary operators ;)
and : B -> B -> B := x : B => y : B => iteb x y false.
or : B -> B -> B := x : B => y : B => iteb x true y.
xor : B -> B -> B := x : B => y : B => iteb x (not y) y.
imp : B -> B -> B := x : B => y : B => iteb x y true.
eqv : B -> B -> B := x : B => y : B => iteb x y (not y).
