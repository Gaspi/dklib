#NAME dk_records
#IMPORT cc
(; Records as finite domain partial functions ;)


(; Labels are strings ;)
#IMPORT dk_string
label := dk_string.string.
Label := cc.eT label.

#IMPORT dk_bool
bool := dk_bool.bool.
Bool := cc.eT bool.
label_eq : Label -> Label -> Bool := dk_string.equal.

(; Domains are lists of labels ;)
#IMPORT dk_list
domain := dk_list.list label.
Domain := cc.eT domain.
domain_nil := dk_list.nil label.
domain_cons := dk_list.cons label.

domain_mem : Label -> Domain -> Bool.
[ l : Label ] domain_mem l (dk_list.nil label) --> dk_bool.false
[ l1 : Label, l2 : Label, d : Domain ]
   domain_mem l1 (dk_list.cons label l2 d)
   -->
   dk_bool.or (label_eq l1 l2) (domain_mem l1 d).

(; partial functions ;)
(; partial functions from A to B can be seen as functions from A to option B ;)
#IMPORT dk_opt
option := dk_opt.option.
Option := A : cc.uT => cc.eT (option A).
partial := A : cc.uT =>
           B : (cc.eT A -> cc.uT) =>
           cc.Pi_TTT A (a : cc.eT A => option (B a)).
Partial := A : cc.uT =>
           B : (cc.eT A -> cc.uT) =>
           a : cc.eT A ->
           Option (B a).

(; partial functions from A to B can alternatively be seen as partially defined
   functions from A to B ;)
(; simple but a priori "unsafe" way to see a function from A to option B
   as a function from A to B ;)
option_unsafe_get : A : cc.uT -> oA : Option A -> cc.eT A.
[ A : cc.uT, a : cc.eT A ] option_unsafe_get A (dk_opt.Some A a) --> a.
unsafe_partial : A : cc.uT ->
                 B : (cc.eT A -> cc.uT) ->
                 f : Partial A B ->
                 a : cc.eT A ->
                 cc.eT (B a)
 :=
                 A : cc.uT =>
                 B : (cc.eT A -> cc.uT) =>
                 f : Partial A B =>
                 a : cc.eT A =>
                 option_unsafe_get (B a) (f a).

(; another way using proof of membership in the domain ;)
is_some : A : cc.uT ->
          Option A ->
          Bool
 :=
          A : cc.uT =>
          dk_opt.simple_match_option
            A
            bool
            dk_bool.false
            (a : cc.eT A => dk_bool.true).

option_safe_get : A : cc.uT ->
                  oa : Option A ->
                  H : dk_logic.eP (dk_logic.ebP (is_some A oa)) ->
                  cc.eT A
 :=
                  A : cc.uT =>
                  dk_opt.match_option
                     A
                     (oa : Option A =>
                         cc.Arrow
                            (dk_logic.eeP (dk_logic.ebP (is_some A oa)))
                            A)
                     (dk_logic.False_elim A)
                     (a : cc.eT A => I : (dk_logic.eP dk_logic.True) => a).

safe_partial : A : cc.uT ->
               B : (cc.eT A -> cc.uT) ->
               f : Partial A B ->
               a : cc.eT A ->
               H : dk_logic.eP (dk_logic.ebP (is_some (B a) (f a))) ->
               cc.eT (B a)
 :=
               A : cc.uT =>
               B : (cc.eT A -> cc.uT) =>
               f : Partial A B =>
               a : cc.eT A =>
               H : dk_logic.eP (dk_logic.ebP (is_some (B a) (f a))) =>
               option_safe_get (B a) (f a) H.

(; Finite domain ;)

domain_mem_some : f : (Label -> cc.uT) ->
                  D : Domain ->
                  fun : Partial label f ->
                  dk_logic.P
:=
                  f : (Label -> cc.uT) =>
                  D : Domain =>
                  fun : Partial label f =>
                  dk_logic.forall label (l : Label =>
                  dk_logic.ebP (
                    dk_bool.imp
                       (domain_mem l D)
                       (is_some (f l) (fun l)))).

Record : f : (Label -> cc.uT) -> Type.

Record_domain : f : (Label -> cc.uT) ->
                R : Record f ->
                Domain.

Record_fun : f : (Label -> cc.uT) ->
             R : Record f ->
             Partial label f.

Record_cert : f : (Label -> cc.uT) ->
              R : Record f ->
              dk_logic.eP (domain_mem_some f (Record_domain f R) (Record_fun f R)).

mk_record : f : (Label -> cc.uT) ->
            D : Domain ->
            fun : Partial label f ->
            cert : dk_logic.eP (domain_mem_some f D fun) ->
            Record f.

[ f : Label -> cc.uT,
  D : Domain,
  fun : Partial label f,
  cert : dk_logic.eP (domain_mem_some f D fun) ]
  Record_domain {f} (mk_record f D fun cert) --> D.

[ f : Label -> cc.uT,
  D : Domain,
  fun : Partial label f,
  cert : dk_logic.eP (domain_mem_some f D fun) ]
  Record_fun {f} (mk_record f D fun cert) --> fun.

[ f : Label -> cc.uT,
  D : Domain,
  fun : Partial label f,
  cert : dk_logic.eP (domain_mem_some f D fun) ]
  Record_cert {f} (mk_record f D fun cert) --> cert.

Record_apply : f : (Label -> cc.uT) ->
               R : Record f ->
               l : Label ->
               dk_logic.eP
                  (dk_logic.ebP (domain_mem l (Record_domain f R))) ->
               cc.eT (f l)
 :=
               f : (cc.eT label -> cc.uT) =>
               R : Record f =>
               l : Label =>
               H : dk_logic.eP
                  (dk_logic.ebP (domain_mem l (Record_domain f R))) =>
               safe_partial
                  label
                  f
                  (Record_fun f R)
                  l
                  (dk_logic.imp_transfer
                     (domain_mem l (Record_domain f R))
                     (is_some (f l) (Record_fun f R l))
                     (Record_cert f R l)
                     H).

RecordType_f := l : Label => cc.uuT.
RecordType := Record RecordType_f.
mkRecordType := mk_record RecordType_f.

(; RecordTerm_f := Record_apply RecordType_f. ;)
(; RecordTerm := A : RecordType => Record (RecordTerm_f A). ;)

(; Examples ;)

x : Label := dk_list.cons dk_char.char dk_char.x (dk_list.nil dk_char.char).

empty := l : Label => dk_opt.None cc.uuT.

update :=
       f : (Label -> Option cc.uuT) =>
       l1 : Label =>
       A : cc.uT =>
       l2 : Label =>
       dk_bool.ite (dk_opt.option cc.uuT)
          (label_eq l1 l2)
          (dk_opt.Some cc.uuT A)
          (f l2).

update_domain :
              f : (cc.eT label -> cc.eT (dk_opt.option cc.uuT)) ->
              D : cc.eT label_list ->
              l1 : cc.eT label ->
              A : cc.uT ->
              cc.eP (domain_match RecordType_f D f) ->
              cc.eP (domain_match RecordType_f (cons l1 D) (update f l1 A))
:=
              f : (cc.eT label -> cc.eT (dk_opt.option cc.uuT)) =>
              D : cc.eT label_list =>
              l1 : cc.eT label =>
              A : cc.uT =>
              H : cc.eP (domain_match RecordType_f D f) =>

              cc.eP (domain_match RecordType_f (cons l1 D) (update f l1 A)).


Point : RecordType := mk_record (l : cc.eT label => cc.uuT) (label_cons x label_nil) (update empty x dk_nat.Nat).





(; Functional Lens ;)

(; Partial Function ;)
(; Finite Domain Function := A : type -> T : (A -> type) -> (D : list A * f : (a : A -> option (T a)) avec f a = None <-> not mem a D) ;)
(; apply : A : type -> B : (A -> type) -> f : (FDF A B) -> a : A -> H : indomain a f -> B a ;)
(; MyRecordType = FDF label (l : label => type) ;)
(; MyRecord = FDF label (field MyRecord (apply label (l : label => type) MyRecordType)) ;)

#IMPORT dk_bool

(; label : cc.uT. ;)
(; lab_eq : cc.eT label -> cc.eT label -> dk_bool.B. ;)

#IMPORT dk_list
#IMPORT dk_opt




(; FDF : Type. ;)

(; FDF_domain : ;)
(;     FDF -> ;)
(;     cc.eT (dk_list.list label). ;)

(; indomain : FDF -> label -> bool := list_rec  ;)

(; FDF_ret : ;)
(;     FDF -> ;)
(;     cc.eT label -> ;)
(;     cc.uT. ;)

(; FDF_fun : ;)
(;     f : FDF -> ;)
(;     l : cc.eT label -> ;)
(;     cc.eT (dk_opt.option (FDF_ret f l)). ;)


(; mk_FDF :  ;)





(; type2 : type. ;)
(; term2 : term type2 -> type. ;)
(; Term2 : term type2 -> Type := t2 : term type2 => term (term2 t2). ;)


(; RecordType : type := list (label * type). ;)

(; Record : RT : RecordType -> type. ;)
(; NilRec : RT : RecordType -> Record  ;)





(; field : type -> type -> type. ;)
(; (\; field A B <=> A is a field of B ;\) ;)
(; get : A : type -> B : type -> field A B -> B -> A. ;)
(; set : A : type -> B : type -> field A B -> B -> A -> B. ;)


(; RecordType : type := list (label * field A B ;)







(; optiontype : Type. ;)
(; Nonetype : optiontype. ;)
(; Sometype : type -> optiontype. ;)

(; ObjectType : Type := term label -> optiontype. ;)

(; typeList : Type. ;)
(; typeNil : typeList. ;)
(; typeCons : type -> typeList -> typeList. ;)





(; Method : type -> type -> type. ;)
(; zeta : A : type -> B : type -> (term A -> term B) -> term (Method A B). ;)


