#NAME dk_zeta_FO

(; First Order รง-calculus ;)

label := dk_lrecords.label.
Label := cc.eT label.
Domain := dk_lrecords.Domain.
label_eq := dk_lrecords.label_eq.
bool := dk_bool.bool.
Bool := cc.eT bool.
istrue := b : Bool => dk_logic.eeP (dk_logic.ebP b).
Istrue := b : Bool => cc.eT (istrue b).

(; Object/expression types are records of types ;)
TTyper := l : Label => cc.uuT. (; Typer for types ;)
Record := dk_lrecords.Record TTyper.

expr : D : Domain -> Record D -> cc.uT.
Expr : D : Domain -> Record D -> Type
 := D : Domain => r : Record D => cc.eT (expr D r).

(; Methods are functions from expressions to anything ;)
method := D : Domain => r : Record D =>
          A : cc.uT =>
          cc.Arrow (expr D r) A.
Method := D : Domain => r : Record D =>
          A : cc.uT =>
          Expr D r -> cc.eT A.
(; We usually need A = r l for some label l ;)
lmethod := D : Domain => r : Record D =>
           l : Label => method D r (r l).
Lmethod := D : Domain => r : Record D =>
           l : Label => Method D r (r l).

object : D : Domain -> Record D -> cc.uT
:= D : Domain => r : Record D =>
   dk_lrecords.record (lmethod D r) D.
Object : D : Domain -> Record D -> Type
 := D : Domain => r : Record D => cc.eT (object D r).

Empty : Record dk_lrecords.domain_nil.
empty_object : Object dk_lrecords.domain_nil Empty.
(; The updated method keep the same type r l. ;)
update_object : D : Domain -> r : Record D ->
                Object D r -> l : Label ->
                Lmethod D r l ->
                Object D r
:=
                D : Domain => r : Record D =>
                o : Object D r => l : Label =>
                m : Method D r (r l) =>
                l2 : Label =>
                (; We want to write 
                   dk_bool.ite (lmethod D r l2)
                      (label_eq l2 l)
                      m
                      (o l2)
                   but this is ill-typed
                ;)
                dk_lrecords.if_label_eq (lmethod D r) l l2
                  m
                  (o l2).

make : D : Domain -> r : Record D -> Object D r -> Expr D r.
select : D : Domain -> r : Record D -> Expr D r -> l : Label -> cc.eT (r l).
update : D : Domain -> r : Record D -> Expr D r -> l : Label -> Method D r (r l) -> Expr D r.

[D : Domain,
 r : Record D,
 o : Object D r,
 l : Label]
   select D r (make _ _ o) l
    --> o l (make D r o).
[D : Domain,
 r : Record D,
 o : Object D r,
 l : Label,
 m : Method D r (r l)]
   update D r (make _ _ o) l m
    --> make D r (update_object D r o l m).

AssocTT_cons := dk_lrecords.AssocT_cons TTyper.
AssocTT_nil := dk_lrecords.AssocT_nil TTyper.
mk_coupleTT := dk_lrecords.mk_couple TTyper.

(; Exemples;)
l_if : Label := dk_list.cons dk_char.char dk_char.i (
                dk_list.cons dk_char.char dk_char.f (
                dk_list.nil dk_char.char)).
l_then : Label := dk_list.cons dk_char.char dk_char.t (
                  dk_list.cons dk_char.char dk_char.h (
                  dk_list.cons dk_char.char dk_char.e (
                  dk_list.cons dk_char.char dk_char.n (
                  dk_list.nil dk_char.char)))).
l_else : Label := dk_list.cons dk_char.char dk_char.e (
                  dk_list.cons dk_char.char dk_char.l (
                  dk_list.cons dk_char.char dk_char.s (
                  dk_list.cons dk_char.char dk_char.e (
                  dk_list.nil dk_char.char)))).
d_ite : Domain := dk_lrecords.domain_cons l_if (
                  dk_lrecords.domain_cons l_then (
                  dk_lrecords.domain_cons l_else (
                  dk_lrecords.domain_nil))).

BoolT : A : cc.uT -> Record d_ite
     := A : cc.uT =>
          dk_lrecords.AssocT_list_record
              (l : Label => cc.uuT)
              (AssocTT_cons (mk_coupleTT l_if A) (
               AssocTT_cons (mk_coupleTT l_then A) (
               AssocTT_cons (mk_coupleTT l_else A) (
               AssocTT_nil)))).

trueT : A : cc.uT -> Expr d_ite (BoolT A)
      := A : cc.uT =>
         make d_ite (BoolT A)
           (l : Label =>
              dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_if l
                (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_then)
                (dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_then l
                   (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_then)
                   (dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_else l
                      (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_else)
                      (; Default case ;)
                      (self : Expr d_ite (BoolT A) => dk_fail.fail (BoolT A l))))).

falseT : A : cc.uT -> Expr d_ite (BoolT A)
      := A : cc.uT =>
         make d_ite (BoolT A)
           (l : Label =>
              dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_if l
                (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_else)
                (dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_then l
                   (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_then)
                   (dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_else l
                      (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_else)
                      (; Default case ;)
                      (self : Expr d_ite (BoolT A) => dk_fail.fail (BoolT A l))))).

ifT : A : cc.uT -> Expr d_ite (BoolT A) -> cc.eT A -> cc.eT A -> cc.eT A
    := A : cc.uT =>
       b : Expr d_ite (BoolT A) =>
       then : cc.eT A =>
       else : cc.eT A =>
       select d_ite (BoolT A)
         (update d_ite (BoolT A)
           (update d_ite (BoolT A)
             b
             l_then
             (self : Expr d_ite (BoolT A) => then))
           l_else
           (self : Expr d_ite (BoolT A) => else))
         l_if.

(; A : cc.uT. ;)
(; t : cc.eT A. ;)
(; e : cc.eT A. ;)
(; #ASSERT (ifT A (trueT A) t e) ~= t. ;)
(; #ASSERT (ifT A (falseT A) t e) ~= e. ;)