#NAME dk_zeta_FO

(; First Order ç-calculus ;)

label := dk_lrecords.label.
Label := cc.eT label.
Domain := dk_lrecords.Domain.
label_eq := dk_lrecords.label_eq.
bool := dk_bool.bool.
Bool := cc.eT bool.
istrue := b : Bool => dk_logic.eeP (dk_logic.ebP b).
Istrue := b : Bool => cc.eT (istrue b).

(; Object/expression types are records of types ;)
TTyper := l : Label => cc.uuT. (; Typer for types ;)
Record := dk_lrecords.Record TTyper.

expr : D : Domain -> Record D -> cc.uT.
Expr : D : Domain -> Record D -> Type
 := D : Domain => r : Record D => cc.eT (expr D r).

(; Methods are functions from expressions to anything ;)
method := D : Domain => r : Record D =>
          A : cc.uT =>
          cc.Arrow (expr D r) A.
Method := D : Domain => r : Record D =>
          A : cc.uT =>
          Expr D r -> cc.eT A.
(; We usually need A = r l for some label l ;)
lmethod := D : Domain => r : Record D =>
           l : Label => method D r (r l).
Lmethod := D : Domain => r : Record D =>
           l : Label => Method D r (r l).

object : D : Domain -> Record D -> cc.uT
:= D : Domain => r : Record D =>
   dk_lrecords.record (lmethod D r) D.
Object : D : Domain -> Record D -> Type
 := D : Domain => r : Record D => cc.eT (object D r).

Empty : Record dk_lrecords.domain_nil.
empty_object : Object dk_lrecords.domain_nil Empty.
(; The updated method keep the same type r l. ;)
update_object : D : Domain -> r : Record D ->
                Object D r -> l : Label ->
                Lmethod D r l ->
                Object D r
:=
                D : Domain => r : Record D =>
                o : Object D r => l : Label =>
                m : Method D r (r l) =>
                l2 : Label =>
                (; We want to write 
                   dk_bool.ite (lmethod D r l2)
                      (label_eq l2 l)
                      m
                      (o l2)
                   but this is ill-typed
                ;)
                dk_lrecords.if_label_eq (lmethod D r) l l2
                  m
                  (o l2).

make : D : Domain -> r : Record D -> Object D r -> Expr D r.
select : D : Domain -> r : Record D -> Expr D r -> l : Label -> cc.eT (r l).
update : D : Domain -> r : Record D -> Expr D r -> l : Label -> Lmethod D r l -> Expr D r.

[D : Domain,
 r : Record D,
 o : Object D r,
 l : Label]
   select D r (make _ _ o) l
    --> o l (make D r o).
[D : Domain,
 r : Record D,
 o : Object D r,
 l : Label,
 m : Method D r (r l)]
   update D r (make _ _ o) l m
    --> make D r (update_object D r o l m).

AssocTT_cons := dk_lrecords.AssocT_cons TTyper.
AssocTT_nil := dk_lrecords.AssocT_nil TTyper.
mk_coupleTT := dk_lrecords.mk_couple TTyper.

(; Exemples;)
l_if : Label := dk_list.cons dk_char.char dk_char.i (
                dk_list.cons dk_char.char dk_char.f (
                dk_list.nil dk_char.char)).
l_then : Label := dk_list.cons dk_char.char dk_char.t (
                  dk_list.cons dk_char.char dk_char.h (
                  dk_list.cons dk_char.char dk_char.e (
                  dk_list.cons dk_char.char dk_char.n (
                  dk_list.nil dk_char.char)))).
l_else : Label := dk_list.cons dk_char.char dk_char.e (
                  dk_list.cons dk_char.char dk_char.l (
                  dk_list.cons dk_char.char dk_char.s (
                  dk_list.cons dk_char.char dk_char.e (
                  dk_list.nil dk_char.char)))).
d_ite : Domain := dk_lrecords.domain_cons l_if (
                  dk_lrecords.domain_cons l_then (
                  dk_lrecords.domain_cons l_else (
                  dk_lrecords.domain_nil))).

BoolT : A : cc.uT -> Record d_ite
     := A : cc.uT =>
          dk_lrecords.AssocT_list_record
              (l : Label => cc.uuT)
              (AssocTT_cons (mk_coupleTT l_if A) (
               AssocTT_cons (mk_coupleTT l_then A) (
               AssocTT_cons (mk_coupleTT l_else A) (
               AssocTT_nil)))).

trueT : A : cc.uT -> Expr d_ite (BoolT A)
      := A : cc.uT =>
         make d_ite (BoolT A)
           (l : Label =>
              dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_if l
                (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_then)
                (dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_then l
                   (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_then)
                   (dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_else l
                      (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_else)
                      (; Default case ;)
                      (self : Expr d_ite (BoolT A) => dk_fail.fail (BoolT A l))))).

falseT : A : cc.uT -> Expr d_ite (BoolT A)
      := A : cc.uT =>
         make d_ite (BoolT A)
           (l : Label =>
              dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_if l
                (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_else)
                (dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_then l
                   (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_then)
                   (dk_lrecords.if_label_eq (lmethod d_ite (BoolT A)) l_else l
                      (self : Expr d_ite (BoolT A) => select d_ite (BoolT A) self l_else)
                      (; Default case ;)
                      (self : Expr d_ite (BoolT A) => dk_fail.fail (BoolT A l))))).

ifT : A : cc.uT -> Expr d_ite (BoolT A) -> cc.eT A -> cc.eT A -> cc.eT A
    := A : cc.uT =>
       b : Expr d_ite (BoolT A) =>
       then : cc.eT A =>
       else : cc.eT A =>
       select d_ite (BoolT A)
         (update d_ite (BoolT A)
           (update d_ite (BoolT A)
             b
             l_then
             (self : Expr d_ite (BoolT A) => then))
           l_else
           (self : Expr d_ite (BoolT A) => else))
         l_if.

(; A : cc.uT. ;)
(; t : cc.eT A. ;)
(; e : cc.eT A. ;)
(; #ASSERT (ifT A (trueT A) t e) ~= t. ;)
(; #ASSERT (ifT A (falseT A) t e) ~= e. ;)


(; Sous-typage ;)
cast : DA : Domain ->
       DB : Domain ->
       RA : Record DA ->
       RB : Record DB ->
       Expr DA RA ->
       Expr DB RB.

[ DA : Domain,
  DB : Domain,
  RA : Record DA,
  RB : Record DB,
  oA : Object DA RA]
    cast DA DB RA RB (make _ _ oA)
-->
    make DB RB (l : Label => self : Expr DB RB => select DB RB self l).

(; Exemple ;)
l_get : Label := dk_list.cons dk_char.char dk_char.g (
                 dk_list.cons dk_char.char dk_char.e (
                 dk_list.cons dk_char.char dk_char.t (
                 dk_list.nil dk_char.char))).
d_get : Domain := dk_lrecords.domain_cons l_get (
                  dk_lrecords.domain_nil).

RomCell : Record d_get
:=
     dk_lrecords.AssocT_list_record
               (l : Label => cc.uuT)
               (AssocTT_cons (mk_coupleTT l_get dk_nat.Nat) (
               AssocTT_nil)).

l_set : Label := dk_list.cons dk_char.char dk_char.s (
                 dk_list.cons dk_char.char dk_char.e (
                 dk_list.cons dk_char.char dk_char.t (
                 dk_list.nil dk_char.char))).

d_get_set : Domain := dk_lrecords.domain_cons l_set d_get.

PromCell : Record d_get_set
:=
     dk_lrecords.AssocT_list_record
               (l : Label => cc.uuT)
               (AssocTT_cons (mk_coupleTT l_get dk_nat.Nat) (
               (AssocTT_cons (mk_coupleTT l_set
                         (cc.Arrow dk_nat.Nat (expr d_get RomCell))) (
               (AssocTT_nil))))).

l_contents : Label := dk_list.cons dk_char.char dk_char.c (
                      dk_list.cons dk_char.char dk_char.o (
                      dk_list.cons dk_char.char dk_char.n (
                      dk_list.cons dk_char.char dk_char.t (
                      dk_list.cons dk_char.char dk_char.e (
                      dk_list.cons dk_char.char dk_char.n (
                      dk_list.cons dk_char.char dk_char.t (
                      dk_list.cons dk_char.char dk_char.s (
                      dk_list.nil dk_char.char)))))))).

d_gsc : Domain := dk_lrecords.domain_cons l_contents d_get_set.

PrivateCell : Record d_gsc
:=
     dk_lrecords.AssocT_list_record
               (l : Label => cc.uuT)
               (AssocTT_cons (mk_coupleTT l_get dk_nat.Nat) (
               (AssocTT_cons (mk_coupleTT l_set
                         (cc.Arrow dk_nat.Nat (expr d_get RomCell))) (
               (AssocTT_cons (mk_coupleTT l_contents dk_nat.Nat)
               (AssocTT_nil)))))).

Private_to_Rom : Expr d_gsc PrivateCell
                  -> Expr d_get RomCell
:= cast d_gsc d_get PrivateCell RomCell.
Private_to_Prom : Expr d_gsc PrivateCell
                  -> Expr d_get_set PromCell
:= cast d_gsc d_get_set PrivateCell PromCell.

myCell : Expr d_get_set PromCell
:=
    Private_to_Prom (
      make d_gsc PrivateCell
      (l : Label =>
           dk_lrecords.if_label_eq (lmethod d_gsc PrivateCell) l_contents l
              (self : Expr d_gsc PrivateCell => dk_nat.O)
              (dk_lrecords.if_label_eq (lmethod d_gsc PrivateCell) l_get l
                   (self : Expr d_gsc PrivateCell => select d_gsc PrivateCell self l_contents)
                   (dk_lrecords.if_label_eq (lmethod d_gsc PrivateCell) l_set l
                      (self : Expr d_gsc PrivateCell => n : dk_nat.N => Private_to_Rom (update d_gsc PrivateCell self l_contents (s : Expr d_gsc PrivateCell => n)))
                      (; Default case ;)
                      (self : Expr d_gsc PrivateCell => dk_fail.fail (PrivateCell l)))))).

(; The following check makes Dedukti use all the RAM… ;)
(; := select d_get RomCell ;)
(;    (select d_get_set PromCell myCell l_set dk_nat.__3) ;)
(;    l_get. ;)

