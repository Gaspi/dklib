#NAME dk_logic
#IMPORT cc
#IMPORT dk_bool

Prop : cc.uT.
P : Type := cc.eT Prop.
eP : P -> Type := cc.e Prop.
eeP : P -> cc.uT := cc.ee Prop.
ebP : cc.eT dk_bool.bool -> P.

True : P.
False : P.
not : P -> P.
and : P -> P -> P.
or : P -> P -> P.
xor : P -> P -> P.
imp : P -> P -> P
:= f1 : P => f2 : P => cc.Pi_TAA Prop (eeP f1) (x: cc.eT (eeP f1) => f2).
eqv : P -> P -> P
:= f1 : P => f2 : P => and (imp f1 f2) (imp f1 f2).
forall : A : cc.uT -> (x : cc.eT A -> P) -> P
:= A : cc.uT => f : (x : cc.eT A -> P) => cc.Pi_TAA Prop A f.
exists : A : cc.uT -> (x : cc.eT A -> P) -> P.

I : eP True.

[] ebP dk_bool.true --> True
[] ebP dk_bool.false --> False.

(; Magic proof ;)
(; Definition of assumed proofs ;)
magic_proof : p : P -> eP p.

(; equality ;)
equal : A : cc.uT -> x : cc.eT A -> y : cc.eT A -> P.
refl : A : cc.uT -> x : cc.eT A -> eP (equal A x x). 

equal_ind : A : cc.uT -> P : (cc.eT A -> cc.uT) -> x : cc.eT A -> y : cc.eT A -> eP (equal A x y) -> cc.eT (P x) -> cc.eT (P y).

equal_congr :
   A : cc.uT ->
   B : cc.uT ->
   f : (cc.eT A -> cc.eT B) ->
   x : cc.eT A ->
   y : cc.eT A ->
   eP (equal A x y) ->
   eP (equal B (f x) (f y))
:=
   A : cc.uT =>
   B : cc.uT =>
   f : (cc.eT A -> cc.eT B) =>
   x : cc.eT A =>
   y : cc.eT A =>
   H : eP (equal A x y) =>
   equal_ind A (z : cc.eT A => eeP (equal B (f x) (f z))) x y H (refl B (f x)).
