#NAME dk_logic
#IMPORT cc
#IMPORT dk_bool

Prop : cc.uT.
P : Type := cc.eT Prop.
eP : P -> Type := cc.e Prop.
eeP : P -> cc.uT := cc.ee Prop.
ebP : cc.eT dk_bool.bool -> P.

True : P := ebP dk_bool.true.
False : P := ebP dk_bool.false.
imp : P -> P -> P
:= f1 : P => f2 : P => cc.Pi_TAA Prop (eeP f1) (x: cc.eT (eeP f1) => f2).
not : P -> P := f : P => imp f False.
and : P -> P -> P.
or : P -> P -> P.
xor : P -> P -> P.
eqv : P -> P -> P
:= f1 : P => f2 : P => and (imp f1 f2) (imp f2 f1).
forall : A : cc.uT -> (x : cc.eT A -> P) -> P
:= A : cc.uT => f : (x : cc.eT A -> P) => cc.Pi_TAA Prop A f.
exists : A : cc.uT -> (x : cc.eT A -> P) -> P.

I : eP True.
False_elim : A : cc.uT -> eP False -> cc.eT A.

and_intro : f1 : P ->
            f2 : P ->
            eP f1 ->
            eP f2 ->
            eP (and f1 f2).
and_elim1 : f1 : P ->
            f2 : P ->
            eP (and f1 f2) ->
            eP f1.
and_elim2 : f1 : P ->
            f2 : P ->
            eP (and f1 f2) ->
            eP f2.
(; cut elimination ;)
[f1 : P, f2 : P,
 H1 : eP f1, H2 : eP f2]
   and_elim1 {f1} {f2} (and_intro f1 f2 H1 H2) --> H1.
[f1 : P, f2 : P,
 H1 : eP f1, H2 : eP f2]
   and_elim2 {f1} {f2} (and_intro f1 f2 H1 H2) --> H2.

eqv_intro := f1 : P =>
             f2 : P =>
             and_intro (imp f1 f2) (imp f2 f1).
eqv_elim1 := f1 : P =>
             f2 : P =>
             and_elim1 (imp f1 f2) (imp f2 f1).
eqv_elim2 := f1 : P =>
             f2 : P =>
             and_elim2 (imp f1 f2) (imp f2 f1).

imp_transfer :
  b1 : cc.eT dk_bool.bool ->
  b2 : cc.eT dk_bool.bool ->
  eP (ebP (dk_bool.imp b1 b2)) ->
  eP (imp (ebP b1) (ebP b2))
:=
  dk_bool.match
    (b1 : cc.eT dk_bool.bool =>
      eeP (forall dk_bool.bool
        (b2 : cc.eT dk_bool.bool =>
           imp (ebP (dk_bool.imp b1 b2))
           (imp (ebP b1) (ebP b2)))))
    (b2 : cc.eT dk_bool.bool =>
     H : eP (ebP b2) =>
     I : eP True =>
     H)
    (b2 : cc.eT dk_bool.bool =>
     I : eP True =>
     H : eP False =>
     False_elim (eeP (ebP b2)) H).

and_transfer :
  b1 : cc.eT dk_bool.bool ->
  b2 : cc.eT dk_bool.bool ->
  eP (ebP (dk_bool.and b1 b2)) ->
  eP (and (ebP b1) (ebP b2))
:=
  dk_bool.match
    (b1 : cc.eT dk_bool.bool =>
      eeP (forall dk_bool.bool
        (b2 : cc.eT dk_bool.bool =>
           imp (ebP (dk_bool.and b1 b2))
           (and (ebP b1) (ebP b2)))))
    (b2 : cc.eT dk_bool.bool =>
     H : eP (ebP b2) =>
     and_intro True (ebP b2) I H)
    (b2 : cc.eT dk_bool.bool =>
     H  : eP False =>
     False_elim (eeP (and False (ebP b2))) H).

not_transfer :
  b : cc.eT dk_bool.bool ->
  eP (ebP (dk_bool.not b)) ->
  eP (not (ebP b))
:=
  dk_bool.match
    (b : cc.eT dk_bool.bool =>
      eeP (imp
            (ebP (dk_bool.not b))
            (not (ebP b))))
    (H : eP False => I : eP True => H)
    (I : eP True => H : eP False => H).

eqv_transfer :
  b1 : cc.eT dk_bool.bool ->
  b2 : cc.eT dk_bool.bool ->
  eP (ebP (dk_bool.eqv b1 b2)) ->
  eP (eqv (ebP b1) (ebP b2))
:=
  dk_bool.match
    (b1 : cc.eT dk_bool.bool =>
      eeP (forall dk_bool.bool
        (b2 : cc.eT dk_bool.bool =>
           imp (ebP (dk_bool.eqv b1 b2))
           (eqv (ebP b1) (ebP b2)))))
    (b2 : cc.eT dk_bool.bool =>
     H : eP (ebP b2) =>
     eqv_intro
       True
       (ebP b2)
       (I : eP True => H)
       (H : eP (ebP b2) => I))
    (b2 : cc.eT dk_bool.bool =>
     H : eP (ebP (dk_bool.not b2)) =>
     eqv_intro
       False
       (ebP b2)
       (False_elim (eeP (ebP b2)))
       (not_transfer b2 H)).

bool_eqv_refl : b : cc.eT dk_bool.bool ->
                eP (ebP (dk_bool.eqv b b))
              := dk_bool.match
                    (b : cc.eT dk_bool.bool => eeP (ebP (dk_bool.eqv b b)))
                    I
                    I.

bool_or_true : b : cc.eT dk_bool.bool ->
               eP (ebP (dk_bool.or b dk_bool.true))
:=
               dk_bool.match
                 (b : cc.eT dk_bool.bool => eeP (ebP (dk_bool.or b dk_bool.true)))
                 I
                 I.

bool_or_false : b : cc.eT dk_bool.bool ->
                eP (ebP b) ->
                eP (ebP (dk_bool.or b dk_bool.false))
:=
               dk_bool.match
                 (b : cc.eT dk_bool.bool => eeP (
                  imp (ebP b)
                      (ebP (dk_bool.or b dk_bool.false))))
                 (I : eP True => I)
                 (H : eP False => H).

bool_or_sym : b1 : cc.eT dk_bool.bool ->
              b2 : cc.eT dk_bool.bool ->
              eP (ebP (dk_bool.or b1 b2)) ->
              eP (ebP (dk_bool.or b2 b1))
:=
              dk_bool.match
                (b1 : cc.eT dk_bool.bool => eeP (
                 forall dk_bool.bool (b2 : cc.eT dk_bool.bool =>
                 imp (ebP (dk_bool.or b1 b2))
                     (ebP (dk_bool.or b2 b1)))))
                (b2 : cc.eT dk_bool.bool =>
                 I : eP True =>
                 bool_or_true b2)
                bool_or_false.

bool_or_intro1 : b1 : cc.eT dk_bool.bool ->
                 b2 : cc.eT dk_bool.bool ->
                 eP (ebP b1) ->
                 eP (ebP (dk_bool.or b1 b2))
:=
                 dk_bool.match
                   (b1 : cc.eT dk_bool.bool => eeP (
                    forall dk_bool.bool (b2 : cc.eT dk_bool.bool =>
                    imp (ebP b1) (ebP (dk_bool.or b1 b2)))))
                   (b2 : cc.eT dk_bool.bool =>
                    I : eP True =>
                    I)
                   (b2 : cc.eT dk_bool.bool =>
                    False_elim (eeP (ebP b2))).

bool_or_intro2 : b1 : cc.eT dk_bool.bool ->
                 b2 : cc.eT dk_bool.bool ->
                 eP (ebP b2) ->
                 eP (ebP (dk_bool.or b1 b2))
:=
                 b1 : cc.eT dk_bool.bool =>
                 b2 : cc.eT dk_bool.bool =>
                 H : eP (ebP b2) =>
                 bool_or_sym b2 b1 (bool_or_intro1 b2 b1 H).

booltype_if_elim : b : cc.eT dk_bool.bool ->
               A : cc.uT ->
               B : cc.uT ->
               eP (ebP b) ->
               cc.eT (dk_bool.ite cc.uuT b A B) ->
               cc.eT A
:=
               dk_bool.match
                 (b : cc.eT dk_bool.bool =>
                   cc.Pi_TTT cc.uuT (A : cc.uT =>
                   cc.Pi_TTT cc.uuT (B : cc.uT =>
                   cc.Arrow (eeP (ebP b)) (
                   cc.Arrow (dk_bool.ite cc.uuT b A B)
                   A))))
                 (A : cc.uT =>
                  B : cc.uT =>
                  I : eP True =>
                  a : cc.eT A =>
                  a)
                 (A : cc.uT =>
                  B : cc.uT =>
                  H : eP False =>
                  b : cc.eT B =>
                  False_elim A H). 

booltype_if_intro : b : cc.eT dk_bool.bool ->
                A : cc.uT ->
                B : cc.uT ->
                eP (ebP b) ->
                cc.eT A ->
                cc.eT (dk_bool.ite cc.uuT b A B)
:=
               dk_bool.match
                 (b : cc.eT dk_bool.bool =>
                   cc.Pi_TTT cc.uuT (A : cc.uT =>
                   cc.Pi_TTT cc.uuT (B : cc.uT =>
                   cc.Arrow (eeP (ebP b)) (
                   cc.Arrow A (dk_bool.ite cc.uuT b A B)))))
                 (A : cc.uT =>
                  B : cc.uT =>
                  I : eP True =>
                  a : cc.eT A =>
                  a)
                 (A : cc.uT =>
                  B : cc.uT =>
                  H : eP False =>
                  a : cc.eT A =>
                  False_elim B H). 


booltype_ifnot_elim : b : cc.eT dk_bool.bool ->
                  A : cc.uT ->
                  B : cc.uT ->
                  eP (ebP (dk_bool.not b)) ->
                  cc.eT (dk_bool.ite cc.uuT b A B) ->
                  cc.eT B
:=
                  dk_bool.match
                    (b : cc.eT dk_bool.bool =>
                      cc.Pi_TTT cc.uuT (A : cc.uT =>
                      cc.Pi_TTT cc.uuT (B : cc.uT =>
                      cc.Arrow (eeP (ebP (dk_bool.not b))) (
                      cc.Arrow (dk_bool.ite cc.uuT b A B)
                      B))))
                    (A : cc.uT =>
                     B : cc.uT =>
                     H : eP False =>
                     a : cc.eT A =>
                     False_elim B H)
                    (A : cc.uT =>
                     B : cc.uT =>
                     I : eP True =>
                     b : cc.eT B =>
                     b). 


bool_if_intro : b : cc.eT dk_bool.bool ->
                H : eP (ebP b) ->
                A : cc.uT ->
                a1 : cc.eT A ->
                a2 : cc.eT A ->
                P : (cc.eT A -> cc.uT) ->
                cc.eT (P a1) ->
                cc.eT (P (dk_bool.ite A b a1 a2))
:=
                dk_bool.match
                  (b : cc.eT dk_bool.bool =>
                    cc.Arrow (eeP (ebP b)) (
                    cc.Pi_TTT cc.uuT (A : cc.uT =>
                    cc.Pi_TTT A (a1 : cc.eT A =>
                    cc.Pi_TTT A (a2 : cc.eT A =>
                    cc.Pi_TTT (cc.Arrow A cc.uuT) (P : (cc.eT A -> cc.uT) => 
                    cc.Arrow (P a1) (P (dk_bool.ite A b a1 a2))))))))
                  (I : eP True =>
                   A : cc.uT =>
                   a1 : cc.eT A =>
                   a2 : cc.eT A =>
                   P : (cc.eT A -> cc.uT) =>
                   H : cc.eT (P a1) =>
                   H)
                  (H : eP False =>
                   A : cc.uT =>
                   a1 : cc.eT A =>
                   a2 : cc.eT A =>
                   P : (cc.eT A -> cc.uT) =>
                   H1 : cc.eT (P a1) =>
                   False_elim (P a2) H).

bool_if_elim : b : cc.eT dk_bool.bool ->
                H : eP (ebP b) ->
                A : cc.uT ->
                a1 : cc.eT A ->
                a2 : cc.eT A ->
                P : (cc.eT A -> cc.uT) ->
                cc.eT (P (dk_bool.ite A b a1 a2)) ->
                cc.eT (P a1)
:=
                dk_bool.match
                  (b : cc.eT dk_bool.bool =>
                    cc.Arrow (eeP (ebP b)) (
                    cc.Pi_TTT cc.uuT (A : cc.uT =>
                    cc.Pi_TTT A (a1 : cc.eT A =>
                    cc.Pi_TTT A (a2 : cc.eT A =>
                    cc.Pi_TTT (cc.Arrow A cc.uuT) (P : (cc.eT A -> cc.uT) => 
                    cc.Arrow (P (dk_bool.ite A b a1 a2)) (P a1)))))))
                  (I : eP True =>
                   A : cc.uT =>
                   a1 : cc.eT A =>
                   a2 : cc.eT A =>
                   P : (cc.eT A -> cc.uT) =>
                   H : cc.eT (P a1) =>
                   H)
                  (H : eP False =>
                   A : cc.uT =>
                   a1 : cc.eT A =>
                   a2 : cc.eT A =>
                   P : (cc.eT A -> cc.uT) =>
                   H1 : cc.eT (P a2) =>
                   False_elim (P a1) H).

bool_ifnot_intro : b : cc.eT dk_bool.bool ->
                H : eP (ebP (dk_bool.not b)) ->
                A : cc.uT ->
                a1 : cc.eT A ->
                a2 : cc.eT A ->
                P : (cc.eT A -> cc.uT) ->
                cc.eT (P a2) ->
                cc.eT (P (dk_bool.ite A b a1 a2))
:=
                dk_bool.match
                  (b : cc.eT dk_bool.bool =>
                    cc.Arrow (eeP (ebP (dk_bool.not b))) (
                    cc.Pi_TTT cc.uuT (A : cc.uT =>
                    cc.Pi_TTT A (a1 : cc.eT A =>
                    cc.Pi_TTT A (a2 : cc.eT A =>
                    cc.Pi_TTT (cc.Arrow A cc.uuT) (P : (cc.eT A -> cc.uT) => 
                    cc.Arrow (P a2) (P (dk_bool.ite A b a1 a2))))))))
                  (H : eP False =>
                   A : cc.uT =>
                   a1 : cc.eT A =>
                   a2 : cc.eT A =>
                   P : (cc.eT A -> cc.uT) =>
                   p : cc.eT (P a2) =>
                   False_elim (P a1) H)
                  (I : eP True =>
                   A : cc.uT =>
                   a1 : cc.eT A =>
                   a2 : cc.eT A =>
                   P : (cc.eT A -> cc.uT) =>
                   p : cc.eT (P a2) =>
                   p).

bool_ifnot_elim : b : cc.eT dk_bool.bool ->
                H : eP (ebP (dk_bool.not b)) ->
                A : cc.uT ->
                a1 : cc.eT A ->
                a2 : cc.eT A ->
                P : (cc.eT A -> cc.uT) ->
                cc.eT (P (dk_bool.ite A b a1 a2)) ->
                cc.eT (P a2)
:=
                dk_bool.match
                  (b : cc.eT dk_bool.bool =>
                    cc.Arrow (eeP (ebP (dk_bool.not b))) (
                    cc.Pi_TTT cc.uuT (A : cc.uT =>
                    cc.Pi_TTT A (a1 : cc.eT A =>
                    cc.Pi_TTT A (a2 : cc.eT A =>
                    cc.Pi_TTT (cc.Arrow A cc.uuT) (P : (cc.eT A -> cc.uT) => 
                    cc.Arrow (P (dk_bool.ite A b a1 a2)) (P a2)))))))
                  (H : eP False =>
                   A : cc.uT =>
                   a1 : cc.eT A =>
                   a2 : cc.eT A =>
                   P : (cc.eT A -> cc.uT) =>
                   p : cc.eT (P a1) =>
                   False_elim (P a2) H)
                  (I : eP True =>
                   A : cc.uT =>
                   a1 : cc.eT A =>
                   a2 : cc.eT A =>
                   P : (cc.eT A -> cc.uT) =>
                   p : cc.eT (P a2) =>
                   p).

(; Magic proof ;)
(; Definition of assumed proofs ;)
magic_proof : p : P -> eP p.



(; equality ;)
equal : A : cc.uT -> x : cc.eT A -> y : cc.eT A -> P
     := A : cc.uT => x : cc.eT A => y : cc.eT A =>
          forall (cc.Arrow A Prop)
          (H : (cc.eT A -> P) =>
          imp (H x) (H y)).
refl : A : cc.uT -> x : cc.eT A -> eP (equal A x x)
    := A : cc.uT => x : cc.eT A =>
           H : (cc.eT A -> P) =>
           px : eP (H x) => px.
equal_ind : A : cc.uT ->
            H : (cc.eT A -> P) ->
            x : cc.eT A ->
            y : cc.eT A ->
            eP (equal A x y) ->
            eP (H x) ->
            eP (H y)
 :=
            A : cc.uT =>
            P : (cc.eT A -> P) =>
            x : cc.eT A =>
            y : cc.eT A =>
            eq: eP (equal A x y) =>
            eq P.

equal_sym : A : cc.uT ->
            x : cc.eT A ->
            y : cc.eT A ->
            eP (equal A x y) ->
            eP (equal A y x)
 :=
            A : cc.uT =>
            x : cc.eT A =>
            y : cc.eT A =>
            eq : eP (equal A x y) =>
            equal_ind
              A
              (z : cc.eT A => equal A z x)
              x
              y
              eq
              (refl A x).

equal_congr :
   A : cc.uT ->
   B : cc.uT ->
   f : (cc.eT A -> cc.eT B) ->
   x : cc.eT A ->
   y : cc.eT A ->
   eP (equal A x y) ->
   eP (equal B (f x) (f y))
:=
   A : cc.uT =>
   B : cc.uT =>
   f : (cc.eT A -> cc.eT B) =>
   x : cc.eT A =>
   y : cc.eT A =>
   H : eP (equal A x y) =>
   equal_ind A (z : cc.eT A => equal B (f x) (f z)) x y H (refl B (f x)).
