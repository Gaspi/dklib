#NAME dk_logic

Prop : cc.uT.
P : Type := cc.eT Prop.
eP : P -> Type := cc.e Prop.
eeP : P -> cc.uT := cc.ee Prop.
ebP : cc.eT dk_bool.bool -> P.

True : P := ebP dk_bool.true.
TrueT : Type := eP True.
False : P := ebP dk_bool.false.
FalseT : Type := eP False.
imp : P -> P -> P
    := f1 : P => f2 : P => cc.Pi_TAA Prop (eeP f1) (x: cc.eT (eeP f1) => f2).
not : P -> P := f : P => imp f False.
and : P -> P -> P.
or : P -> P -> P.
xor : P -> P -> P.
eqv : P -> P -> P
    := f1 : P => f2 : P => and (imp f1 f2) (imp f2 f1).
forall : A : cc.uT -> (x : cc.eT A -> P) -> P
       := A : cc.uT => f : (x : cc.eT A -> P) => cc.Pi_TAA Prop A f.
exists : A : cc.uT -> (x : cc.eT A -> P) -> P.

I : TrueT.
False_elim : A : cc.uT -> FalseT -> cc.eT A.

and_intro : f1 : P ->
            f2 : P ->
            eP f1 ->
            eP f2 ->
            eP (and f1 f2).
and_elim1 : f1 : P ->
            f2 : P ->
            eP (and f1 f2) ->
            eP f1.
and_elim2 : f1 : P ->
            f2 : P ->
            eP (and f1 f2) ->
            eP f2.

or_intro1 : f1 : P ->
            f2 : P ->
            eP f1 ->
            eP (or f1 f2).

or_intro2 : f1 : P ->
            f2 : P ->
            eP f2 ->
            eP (or f1 f2).

or_elim : f1 : P ->
          f2 : P ->
          f3 : P ->
          eP (or f1 f2) ->
          eP (imp f1 f3) ->
          eP (imp f2 f3) ->
          eP f3.

(; cut elimination ;)
[f1 : P, f2 : P,
 H1 : eP f1, H2 : eP f2]
    and_elim1 _ _ (and_intro f1 f2 H1 H2) --> H1.
[f1 : P, f2 : P,
 H1 : eP f1, H2 : eP f2]
    and_elim2 _ _ (and_intro f1 f2 H1 H2) --> H2.

[ f1 : P, f2 : P, f3 : P,
  H1 : eP f1, H13 : eP (imp f1 f3) ]
    or_elim _ _ f3 (or_intro1 f1 f2 H1) H13 _ --> H13 H1
[ f1 : P, f2 : P, f3 : P,
  H2 : eP f2, H23 : eP (imp f2 f3) ]
    or_elim _ _ f3 (or_intro2 f1 f2 H2) _ H23 --> H23 H2.

eqv_intro := f1 : P =>
             f2 : P =>
             and_intro (imp f1 f2) (imp f2 f1).
eqv_elim1 := f1 : P =>
             f2 : P =>
             and_elim1 (imp f1 f2) (imp f2 f1).
eqv_elim2 := f1 : P =>
             f2 : P =>
             and_elim2 (imp f1 f2) (imp f2 f1).

imp_transfer :
  b1 : cc.eT dk_bool.bool ->
  b2 : cc.eT dk_bool.bool ->
  eP (ebP (dk_bool.imp b1 b2)) ->
  eP (imp (ebP b1) (ebP b2))
  :=
    dk_bool.match
      (b1 : cc.eT dk_bool.bool =>
       eeP (forall dk_bool.bool
              (b2 : cc.eT dk_bool.bool =>
               imp (ebP (dk_bool.imp b1 b2))
                   (imp (ebP b1) (ebP b2)))))
      (b2 : cc.eT dk_bool.bool =>
       H : eP (ebP b2) =>
       I : TrueT =>
       H)
      (b2 : cc.eT dk_bool.bool =>
       I : TrueT =>
       H : FalseT =>
       False_elim (eeP (ebP b2)) H).

and_transfer :
  b1 : cc.eT dk_bool.bool ->
  b2 : cc.eT dk_bool.bool ->
  eP (ebP (dk_bool.and b1 b2)) ->
  eP (and (ebP b1) (ebP b2))
  :=
    dk_bool.match
      (b1 : cc.eT dk_bool.bool =>
       eeP (forall dk_bool.bool
              (b2 : cc.eT dk_bool.bool =>
               imp (ebP (dk_bool.and b1 b2))
                   (and (ebP b1) (ebP b2)))))
      (b2 : cc.eT dk_bool.bool =>
       H : eP (ebP b2) =>
       and_intro True (ebP b2) I H)
      (b2 : cc.eT dk_bool.bool =>
       H  : FalseT =>
       False_elim (eeP (and False (ebP b2))) H).

not_transfer :
  b : cc.eT dk_bool.bool ->
  eP (ebP (dk_bool.not b)) ->
  eP (not (ebP b))
  :=
    dk_bool.match
      (b : cc.eT dk_bool.bool =>
       eeP (imp
             (ebP (dk_bool.not b))
             (not (ebP b))))
      (H : FalseT => I : TrueT => H)
      (I : TrueT => H : FalseT => H).

eqv_transfer :
  b1 : cc.eT dk_bool.bool ->
  b2 : cc.eT dk_bool.bool ->
  eP (ebP (dk_bool.eqv b1 b2)) ->
  eP (eqv (ebP b1) (ebP b2))
  :=
    dk_bool.match
      (b1 : cc.eT dk_bool.bool =>
       eeP (forall dk_bool.bool
              (b2 : cc.eT dk_bool.bool =>
               imp (ebP (dk_bool.eqv b1 b2))
                   (eqv (ebP b1) (ebP b2)))))
      (b2 : cc.eT dk_bool.bool =>
       H : eP (ebP b2) =>
       eqv_intro
         True
         (ebP b2)
         (I : TrueT => H)
         (H : eP (ebP b2) => I))
      (b2 : cc.eT dk_bool.bool =>
       H : eP (ebP (dk_bool.not b2)) =>
       eqv_intro
         False
         (ebP b2)
         (False_elim (eeP (ebP b2)))
         (not_transfer b2 H)).    

or_transfer :
  b1 : cc.eT dk_bool.bool ->
  b2 : cc.eT dk_bool.bool ->
  eP (ebP (dk_bool.or b1 b2)) ->
  eP (or (ebP b1) (ebP b2))
  :=
    dk_bool.match
      (b1 : cc.eT dk_bool.bool =>
       eeP (forall dk_bool.bool (b2 : cc.eT dk_bool.bool =>
            imp (ebP (dk_bool.or b1 b2))
            (or (ebP b1) (ebP b2)))))
      (b2 : cc.eT dk_bool.bool =>
       or_intro1 True (ebP b2))
      (b2 : cc.eT dk_bool.bool =>
       or_intro2 False (ebP b2)).

bool_eqv_refl : b : cc.eT dk_bool.bool ->
                eP (ebP (dk_bool.eqv b b))
              := dk_bool.match
                  (b : cc.eT dk_bool.bool => eeP (ebP (dk_bool.eqv b b)))
                  I
                    I.

bool_and_elim1 : b1 : cc.eT dk_bool.bool ->
                 b2 : cc.eT dk_bool.bool ->
                 eP (ebP (dk_bool.and b1 b2)) ->
                 eP (ebP b1)
               :=
                 b1 : cc.eT dk_bool.bool =>
                 b2 : cc.eT dk_bool.bool =>
                 H : eP (ebP (dk_bool.and b1 b2)) =>
                 and_elim1
                   (ebP b1)
                   (ebP b2)
                   (and_transfer b1 b2 H).
bool_and_elim2 : b1 : cc.eT dk_bool.bool ->
                 b2 : cc.eT dk_bool.bool ->
                 eP (ebP (dk_bool.and b1 b2)) ->
                 eP (ebP b2)
               :=
                 b1 : cc.eT dk_bool.bool =>
                 b2 : cc.eT dk_bool.bool =>
                 H : eP (ebP (dk_bool.and b1 b2)) =>
                 and_elim2
                   (ebP b1)
                   (ebP b2)
                   (and_transfer b1 b2 H).
                  
bool_or_true : b : cc.eT dk_bool.bool ->
               eP (ebP (dk_bool.or b dk_bool.true))
             :=
               dk_bool.match
                 (b : cc.eT dk_bool.bool => eeP (ebP (dk_bool.or b dk_bool.true)))
                 I
                   I.

bool_or_false : b : cc.eT dk_bool.bool ->
                eP (ebP b) ->
                eP (ebP (dk_bool.or b dk_bool.false))
              :=
                dk_bool.match
                  (b : cc.eT dk_bool.bool =>
                   eeP (
                     imp (ebP b)
                         (ebP (dk_bool.or b dk_bool.false))))
                  (I : TrueT => I)
                  (H : FalseT => H).

bool_or_sym : b1 : cc.eT dk_bool.bool ->
              b2 : cc.eT dk_bool.bool ->
              eP (ebP (dk_bool.or b1 b2)) ->
              eP (ebP (dk_bool.or b2 b1))
            :=
              dk_bool.match
                (b1 : cc.eT dk_bool.bool =>
                 eeP (
                   forall dk_bool.bool (b2 : cc.eT dk_bool.bool =>
                                        imp (ebP (dk_bool.or b1 b2))
                                            (ebP (dk_bool.or b2 b1)))))
                (b2 : cc.eT dk_bool.bool =>
                 I : TrueT =>
                 bool_or_true b2)
                bool_or_false.

bool_or_intro1 : b1 : cc.eT dk_bool.bool ->
                 b2 : cc.eT dk_bool.bool ->
                 eP (ebP b1) ->
                 eP (ebP (dk_bool.or b1 b2))
               :=
                 dk_bool.match
                   (b1 : cc.eT dk_bool.bool =>
                    eeP (
                      forall dk_bool.bool
                        (b2 : cc.eT dk_bool.bool =>
                         imp (ebP b1) (ebP (dk_bool.or b1 b2)))))
                   (b2 : cc.eT dk_bool.bool =>
                    I : TrueT =>
                    I)
                   (b2 : cc.eT dk_bool.bool =>
                    False_elim (eeP (ebP b2))).

bool_or_intro2 : b1 : cc.eT dk_bool.bool ->
                 b2 : cc.eT dk_bool.bool ->
                 eP (ebP b2) ->
                 eP (ebP (dk_bool.or b1 b2))
               :=
                 b1 : cc.eT dk_bool.bool =>
                 b2 : cc.eT dk_bool.bool =>
                 H : eP (ebP b2) =>
                 bool_or_sym b2 b1 (bool_or_intro1 b2 b1 H).

booltype_if_elim : b : cc.eT dk_bool.bool ->
                   A : cc.uT ->
                   B : cc.uT ->
                   eP (ebP b) ->
                   cc.eT (dk_bool.ite cc.uuT b A B) ->
                   cc.eT A
                 :=
                   dk_bool.match
                     (b : cc.eT dk_bool.bool =>
                      cc.Pi_TTT
                        cc.uuT
                        (A : cc.uT =>
                         cc.Pi_TTT
                           cc.uuT
                           (B : cc.uT =>
                            cc.Arrow (eeP (ebP b)) (
                                     cc.Arrow (dk_bool.ite cc.uuT b A B)
                                              A))))
                     (A : cc.uT =>
                      B : cc.uT =>
                      I : TrueT =>
                      a : cc.eT A =>
                      a)
                     (A : cc.uT =>
                      B : cc.uT =>
                      H : FalseT =>
                      b : cc.eT B =>
                      False_elim A H). 

booltype_if_intro : b : cc.eT dk_bool.bool ->
                    A : cc.uT ->
                    B : cc.uT ->
                    eP (ebP b) ->
                    cc.eT A ->
                    cc.eT (dk_bool.ite cc.uuT b A B)
                  :=
                    dk_bool.match
                      (b : cc.eT dk_bool.bool =>
                       cc.Pi_TTT
                         cc.uuT
                         (A : cc.uT =>
                          cc.Pi_TTT
                            cc.uuT
                            (B : cc.uT =>
                             cc.Arrow (eeP (ebP b)) (
                                      cc.Arrow A (dk_bool.ite cc.uuT b A B)))))
                      (A : cc.uT =>
                       B : cc.uT =>
                       I : TrueT =>
                       a : cc.eT A =>
                       a)
                      (A : cc.uT =>
                       B : cc.uT =>
                       H : FalseT =>
                       a : cc.eT A =>
                       False_elim B H). 


booltype_ifnot_elim : b : cc.eT dk_bool.bool ->
                      A : cc.uT ->
                      B : cc.uT ->
                      eP (ebP (dk_bool.not b)) ->
                      cc.eT (dk_bool.ite cc.uuT b A B) ->
                      cc.eT B
                    :=
                      dk_bool.match
                        (b : cc.eT dk_bool.bool =>
                         cc.Pi_TTT
                           cc.uuT
                           (A : cc.uT =>
                            cc.Pi_TTT
                              cc.uuT
                              (B : cc.uT =>
                               cc.Arrow (eeP (ebP (dk_bool.not b))) (
                                        cc.Arrow (dk_bool.ite cc.uuT b A B)
                                                 B))))
                        (A : cc.uT =>
                         B : cc.uT =>
                         H : FalseT =>
                         a : cc.eT A =>
                         False_elim B H)
                        (A : cc.uT =>
                         B : cc.uT =>
                         I : TrueT =>
                         b : cc.eT B =>
                         b). 


bool_if_intro : b : cc.eT dk_bool.bool ->
                H : eP (ebP b) ->
                A : cc.uT ->
                a1 : cc.eT A ->
                a2 : cc.eT A ->
                P : (cc.eT A -> cc.uT) ->
                cc.eT (P a1) ->
                cc.eT (P (dk_bool.ite A b a1 a2))
              :=
                dk_bool.match
                  (b : cc.eT dk_bool.bool =>
                   cc.Arrow (eeP (ebP b)) (
                            cc.Pi_TTT
                              cc.uuT
                              (A : cc.uT =>
                               cc.Pi_TTT
                                 A
                                 (a1 : cc.eT A =>
                                  cc.Pi_TTT
                                    A
                                    (a2 : cc.eT A =>
                                     cc.Pi_TTT
                                       (cc.Arrow A cc.uuT)
                                       (P : (cc.eT A -> cc.uT) => 
                                        cc.Arrow
                                          (P a1)
                                          (P (dk_bool.ite A b a1 a2))))))))
                  (I : TrueT =>
                   A : cc.uT =>
                   a1 : cc.eT A =>
                   a2 : cc.eT A =>
                   P : (cc.eT A -> cc.uT) =>
                   H : cc.eT (P a1) =>
                   H)
                  (H : FalseT =>
                   A : cc.uT =>
                   a1 : cc.eT A =>
                   a2 : cc.eT A =>
                   P : (cc.eT A -> cc.uT) =>
                   H1 : cc.eT (P a1) =>
                   False_elim (P a2) H).

bool_if_elim : b : cc.eT dk_bool.bool ->
               H : eP (ebP b) ->
               A : cc.uT ->
               a1 : cc.eT A ->
               a2 : cc.eT A ->
               P : (cc.eT A -> cc.uT) ->
               cc.eT (P (dk_bool.ite A b a1 a2)) ->
               cc.eT (P a1)
             :=
               dk_bool.match
                 (b : cc.eT dk_bool.bool =>
                  cc.Arrow
                    (eeP (ebP b))
                    (cc.Pi_TTT
                      cc.uuT
                      (A : cc.uT =>
                       cc.Pi_TTT
                         A
                         (a1 : cc.eT A =>
                          cc.Pi_TTT
                            A
                            (a2 : cc.eT A =>
                             cc.Pi_TTT
                               (cc.Arrow A cc.uuT)
                               (P : (cc.eT A -> cc.uT) => 
                                cc.Arrow
                                  (P (dk_bool.ite A b a1 a2))
                                  (P a1)))))))
                 (I : TrueT =>
                  A : cc.uT =>
                  a1 : cc.eT A =>
                  a2 : cc.eT A =>
                  P : (cc.eT A -> cc.uT) =>
                  H : cc.eT (P a1) =>
                  H)
                 (H : FalseT =>
                  A : cc.uT =>
                  a1 : cc.eT A =>
                  a2 : cc.eT A =>
                  P : (cc.eT A -> cc.uT) =>
                  H1 : cc.eT (P a2) =>
                  False_elim (P a1) H).

bool_ifnot_intro : b : cc.eT dk_bool.bool ->
                   H : eP (ebP (dk_bool.not b)) ->
                   A : cc.uT ->
                   a1 : cc.eT A ->
                   a2 : cc.eT A ->
                   P : (cc.eT A -> cc.uT) ->
                   cc.eT (P a2) ->
                   cc.eT (P (dk_bool.ite A b a1 a2))
                 :=
                   dk_bool.match
                     (b : cc.eT dk_bool.bool =>
                      cc.Arrow
                        (eeP (ebP (dk_bool.not b)))
                        (cc.Pi_TTT
                          cc.uuT
                          (A : cc.uT =>
                           cc.Pi_TTT
                             A
                             (a1 : cc.eT A =>
                              cc.Pi_TTT
                                A
                                (a2 : cc.eT A =>
                                 cc.Pi_TTT
                                   (cc.Arrow A cc.uuT)
                                   (P : (cc.eT A -> cc.uT) => 
                                    cc.Arrow
                                      (P a2)
                                      (P (dk_bool.ite A b a1 a2))))))))
                     (H : FalseT =>
                      A : cc.uT =>
                      a1 : cc.eT A =>
                      a2 : cc.eT A =>
                      P : (cc.eT A -> cc.uT) =>
                      p : cc.eT (P a2) =>
                      False_elim (P a1) H)
                     (I : TrueT =>
                      A : cc.uT =>
                      a1 : cc.eT A =>
                      a2 : cc.eT A =>
                      P : (cc.eT A -> cc.uT) =>
                      p : cc.eT (P a2) =>
                      p).

bool_ifnot_elim : b : cc.eT dk_bool.bool ->
                  H : eP (ebP (dk_bool.not b)) ->
                  A : cc.uT ->
                  a1 : cc.eT A ->
                  a2 : cc.eT A ->
                  P : (cc.eT A -> cc.uT) ->
                  cc.eT (P (dk_bool.ite A b a1 a2)) ->
                  cc.eT (P a2)
                :=
                  dk_bool.match
                    (b : cc.eT dk_bool.bool =>
                     cc.Arrow
                       (eeP (ebP (dk_bool.not b)))
                       (cc.Pi_TTT
                         cc.uuT
                         (A : cc.uT =>
                          cc.Pi_TTT
                            A
                            (a1 : cc.eT A =>
                             cc.Pi_TTT
                               A
                               (a2 : cc.eT A =>
                                cc.Pi_TTT
                                  (cc.Arrow A cc.uuT)
                                  (P : (cc.eT A -> cc.uT) => 
                                   cc.Arrow (P (dk_bool.ite A b a1 a2))
                                            (P a2)))))))
                    (H : FalseT =>
                     A : cc.uT =>
                     a1 : cc.eT A =>
                     a2 : cc.eT A =>
                     P : (cc.eT A -> cc.uT) =>
                     p : cc.eT (P a1) =>
                     False_elim (P a2) H)
                    (I : TrueT =>
                     A : cc.uT =>
                     a1 : cc.eT A =>
                     a2 : cc.eT A =>
                     P : (cc.eT A -> cc.uT) =>
                     p : cc.eT (P a2) =>
                     p).

(; Magic proof ;)
(; Definition of assumed proofs ;)
magic_proof : p : P -> eP p.



(; equality ;)
equal : A : cc.uT -> x : cc.eT A -> y : cc.eT A -> P
      := A : cc.uT => x : cc.eT A => y : cc.eT A =>
                                     forall (cc.Arrow A Prop)
                                            (H : (cc.eT A -> P) =>
                                             imp (H x) (H y)).
refl : A : cc.uT -> x : cc.eT A -> eP (equal A x x)
     := A : cc.uT => x : cc.eT A =>
                     H : (cc.eT A -> P) =>
                     px : eP (H x) => px.
equal_ind : A : cc.uT ->
            H : (cc.eT A -> P) ->
            x : cc.eT A ->
            y : cc.eT A ->
            eP (equal A x y) ->
            eP (H x) ->
            eP (H y)
          :=
            A : cc.uT =>
            P : (cc.eT A -> P) =>
            x : cc.eT A =>
            y : cc.eT A =>
            eq: eP (equal A x y) =>
            eq P.

equal_sym : A : cc.uT ->
            x : cc.eT A ->
            y : cc.eT A ->
            eP (equal A x y) ->
            eP (equal A y x)
          :=
            A : cc.uT =>
            x : cc.eT A =>
            y : cc.eT A =>
            eq : eP (equal A x y) =>
            equal_ind
              A
              (z : cc.eT A => equal A z x)
              x
                y
                eq
                (refl A x).

equal_congr :
  A : cc.uT ->
  B : cc.uT ->
  f : (cc.eT A -> cc.eT B) ->
  x : cc.eT A ->
  y : cc.eT A ->
  eP (equal A x y) ->
  eP (equal B (f x) (f y))
  :=
    A : cc.uT =>
    B : cc.uT =>
    f : (cc.eT A -> cc.eT B) =>
    x : cc.eT A =>
    y : cc.eT A =>
    H : eP (equal A x y) =>
    equal_ind A (z : cc.eT A => equal B (f x) (f z)) x y H (refl B (f x)).
