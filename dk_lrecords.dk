#NAME dk_lrecords
(; Lightweight Records ;)
(; Same as dk_records but encoding partials functions as
    A -> B
   and not
    A -> option B. ;)

(; Labels are strings ;)

label : cc.uT := dk_string.string.
Label := cc.eT label.

bool := dk_bool.bool.
Bool := cc.eT bool.
istrue := b : Bool => dk_logic.eeP (dk_logic.ebP b).
Istrue := b : Bool => cc.eT (istrue b).

label_eq : Label -> Label -> Bool := dk_string.equal.
(; Axiom of correctness ;)
label_eq_rect : l1 : Label ->
                l2 : Label ->
                P : (Label -> cc.uT) ->
                Istrue (label_eq l2 l1) ->
                cc.eT (P l1) ->
                cc.eT (P l2).

[l : Label, P : Label -> cc.uT, H : Istrue (label_eq l l), x : cc.eT (P l)]
    label_eq_rect l l P H x --> x.

(; Dependant if with equality ;)
if_label_eq : P : (Label -> cc.uT) ->
              l1 : Label ->
              l2 : Label ->
              cc.eT (P l1) ->
              cc.eT (P l2) -> cc.eT (P l2)
            :=
              P : (Label -> cc.uT) =>
              l1 : Label =>
              l2 : Label =>
              Heq : cc.eT (P l1) =>
              Hdiff : cc.eT (P l2) =>
              dk_bool.match
                (b : Bool =>
                 cc.Arrow (cc.Arrow (istrue b) (P l2))
                          (cc.Arrow (P l2) (P l2)))
                (H1 : (dk_logic.TrueT -> cc.eT (P l2)) =>
                 H2 : cc.eT (P l2) => H1 dk_logic.I)
                (H1 : (dk_logic.FalseT -> cc.eT (P l2)) =>
                 H2 : cc.eT (P l2) => H2)
                (label_eq l2 l1)
                (H : Istrue (label_eq l2 l1) =>
                 label_eq_rect l1 l2 P H Heq)
                Hdiff.

(; Domains are lists of labels ;)
domain := dk_list.list label.
Domain := cc.eT domain.
domain_nil := dk_list.nil label.
domain_cons := dk_list.cons label.

(; Records ;)

Typer := Label -> cc.uT.

record : f : Typer ->
         D : Domain ->
         cc.uT
       :=
         f : Typer =>
         D : Domain =>
         cc.Pi_TTT label f.

Record : f : Typer ->
         D : Domain ->
         Type
       :=
         f : Typer =>
         D : Domain =>
         l : Label ->
         cc.eT (f l).

(; Examples ;)

x : Label := dk_list.cons dk_char.char dk_char.x (dk_list.nil dk_char.char).
PointDomain : Domain := domain_cons x domain_nil.

PointTyper_aux : Bool -> cc.uT
               := b : Bool => dk_bool.ite cc.uuT b dk_nat.Nat cc.uuT.
PointTyper : Typer
           := l : Label => PointTyper_aux (label_eq l x).

Origin_aux : b : Bool -> cc.eT (PointTyper_aux b)
           := dk_bool.match PointTyper_aux dk_nat.O cc.uuT.
Origin : Record PointTyper PointDomain
       := l : Label => Origin_aux (label_eq l x).

(; From association lists ;)

triple : cc.uT.
Triple := cc.eT triple.
fst : Triple -> Label.
snd : Triple -> cc.uT.
Snd := t : Triple => cc.eT (snd t).
trd : t : Triple -> Snd t.
mk_triple : Label -> A : cc.uT -> cc.eT A -> Triple.
[ l : Label, A : cc.uT, a : cc.eT A ] fst (mk_triple l A a) --> l.
[ l : Label, A : cc.uT, a : cc.eT A ] snd (mk_triple l A a) --> A.
[ l : Label, A : cc.uT, a : cc.eT A ] trd (mk_triple l A a) --> a.

assoc_list := dk_list.list triple.
Assoc_list := cc.eT assoc_list.
Assoc_cons := dk_list.cons triple.
Assoc_nil := dk_list.nil triple.

Assoc_list_domain : Assoc_list -> Domain := dk_list.map triple label fst.

assoc_type : Assoc_list -> Label -> cc.uT.
[ l1 : Label, A : cc.uT, a : cc.eT A,
  L : Assoc_list, l2 : Label ]
    assoc_type (dk_list.cons _ (mk_triple l1 A a) L) l2 -->
    dk_bool.ite cc.uuT
      (label_eq l1 l2)
      A
        (assoc_type L l2).

assoc_val : L : Assoc_list -> l : Label -> cc.eT (assoc_type L l).
[ l1 : Label, A : cc.uT, a : cc.eT A,
  L : Assoc_list, l2 : Label ]
    assoc_val (dk_list.cons _ (mk_triple l1 A a) L) l2 -->
    dk_bool.match
      (b : Bool => dk_bool.ite cc.uuT b A (assoc_type L l2))
      a
        (assoc_val L l2)
        (label_eq l1 l2).

Assoc_list_record : L : Assoc_list ->
                    Record (assoc_type L) (Assoc_list_domain L)
                  := assoc_val.

Origin1D := Assoc_list_record
             (Assoc_cons (mk_triple x dk_nat.Nat dk_nat.O) Assoc_nil).

{ origin1D_x_is_0 } :
dk_logic.eP (dk_logic.equal dk_nat.Nat (Origin1D x) dk_nat.O)
:=
  dk_logic.refl dk_nat.Nat dk_nat.O.

y : Label := dk_list.cons dk_char.char dk_char.y (dk_list.nil dk_char.char).

Origin2D := Assoc_list_record (Assoc_cons (mk_triple x dk_nat.Nat dk_nat.O)
                                          (Assoc_cons (mk_triple y dk_nat.Nat dk_nat.O)
                                                      Assoc_nil)).

{ origin2D_x_is_y } :
dk_logic.eP (dk_logic.equal dk_nat.Nat (Origin2D x) (Origin2D y))
:=
  dk_logic.refl dk_nat.Nat dk_nat.O.

c : Label := dk_list.cons dk_char.char dk_char.c (dk_list.nil dk_char.char).
color : cc.uT.
red : cc.eT color.

ColoredOrigin2D
:= Assoc_list_record (Assoc_cons (mk_triple x dk_nat.Nat dk_nat.O)
                                 (Assoc_cons (mk_triple y dk_nat.Nat dk_nat.O)
                                             (Assoc_cons (mk_triple c color red)
                                                         Assoc_nil))).

(; From association list with a fixed typer ;)

couple : Typer -> cc.uT.
Couple := f : Typer => cc.eT (couple f).
fstT : f : Typer -> Couple f -> Label.
sndT : f : Typer -> c : Couple f -> cc.eT (f (fstT f c)).
mk_couple : f : Typer -> l : Label -> cc.eT (f l) -> Couple f.
[ f : Typer, l : Label, a : cc.eT (f l) ] fstT _ (mk_couple f l a) --> l.
[ f : Typer, l : Label, a : cc.eT (f l) ] sndT _ (mk_couple f l a) --> a.

assocT_list := f : Typer => dk_list.list (couple f).
AssocT_list := f : Typer => cc.eT (assocT_list f).
AssocT_cons := f : Typer => dk_list.cons (couple f).
AssocT_nil := f : Typer => dk_list.nil (couple f).

AssocT_list_domain : f : Typer -> AssocT_list f -> Domain
                   := f : Typer => dk_list.map (couple f) label (fstT f).

assocT_val : f : Typer -> L : AssocT_list f -> l : Label -> cc.eT (f l).
[ f : Typer,
  l1 : Label, a : cc.eT (f l1),
  L : AssocT_list f, l2 : Label ]
    assocT_val f (dk_list.cons _ (mk_couple _ l1 a) L) l2 -->
    if_label_eq f l1 l2
                  a
                  (assocT_val f L l2).

AssocT_list_record : f : Typer ->
                     L : AssocT_list f ->
                     Record f (AssocT_list_domain f L)
                   := assocT_val.

(; To association lists ;)
to_assoc_list : f : Typer ->
                D : Domain ->
                Record f D ->
                Assoc_list
              :=
                f : Typer =>
                D : Domain =>
                R : Record f D =>
                dk_list.map
                  label
                  triple
                  (l : Label => mk_triple l (f l) (R l))
                  D.

(; From association list with an AssocT_list as typer ;)
TTyper := l : Label => cc.uuT.
AssocTT_list := AssocT_list TTyper.
assocTT_val := f : AssocTT_list => l : Label => assocT_val TTyper f l.
coupleR : f : AssocTT_list -> cc.uT.
CoupleR := f : AssocTT_list => cc.eT (coupleR f).
fstR : f : AssocTT_list -> CoupleR f -> Label.
sndR : f : AssocTT_list -> c : CoupleR f -> cc.eT (assocTT_val f (fstR f c)).
mk_coupleR : f : AssocTT_list -> l : Label -> cc.eT (assocTT_val f l) -> CoupleR f.
[ f : AssocTT_list, l : Label, a : cc.eT (assocTT_val f l) ]
    fstR _ (mk_coupleR f l a) --> l.
[ f : AssocTT_list, l : Label, a : cc.eT (assocTT_val f l) ]
    sndR _ (mk_coupleR f l a) --> a.

assocR_list := f : AssocTT_list => dk_list.list (coupleR f).
AssocR_list := f : AssocTT_list => cc.eT (assocR_list f).
AssocR_cons := f : AssocTT_list => dk_list.cons (coupleR f).
AssocR_nil := f : AssocTT_list => dk_list.nil (coupleR f).

AssocR_list_domain : f : AssocTT_list -> AssocR_list f -> Domain
                   := f : AssocTT_list => dk_list.map (coupleR f) label (fstR f).

assocR_val : f : AssocTT_list -> L : AssocR_list f -> l : Label -> cc.eT (assocTT_val f l).
[ f : AssocTT_list,
  l1 : Label, a : cc.eT (assocTT_val f l1),
  L : AssocR_list f, l2 : Label ]
    assocR_val f (dk_list.cons _ (mk_coupleR _ l1 a) L) l2 -->
    if_label_eq (assocTT_val f) l1 l2
                  a
                  (assocR_val f L l2).

AssocR_list_record : f : AssocTT_list ->
                     L : AssocR_list f ->
                     Record (assocTT_val f) (AssocR_list_domain f L)
                   := assocR_val.

(; Association lists subtyping ;)

Assoc_rm : Assoc_list ->
           Label ->
           Assoc_list.
(; Assoc_rm L l
   Remove the first triple of L whith key equal to l.
;)

[ l1 : Label,
  l2 : Label,
  A : cc.uT,
  a : cc.eT A,
  L : Assoc_list ]
    Assoc_rm (dk_list.cons _ (mk_triple l1 A a) L) l2
      -->
    if_label_eq (l : Label => assoc_list
                ) l2 l1
                L
                (Assoc_cons (mk_triple l1 A a) (Assoc_rm L l2)).

Assoc_subtype : Assoc_list ->
                Assoc_list ->
                Assoc_list.
(; when lA <: lB, Assoc_subtype lA lB ~= lB ;)

[] Assoc_subtype (dk_list.nil _) (dk_list.nil _) --> Assoc_nil.

[ l : Assoc_list ]
    Assoc_subtype (dk_list.cons _ _ l) (dk_list.nil _) --> Assoc_subtype l Assoc_nil.

[ lA : Assoc_list,
  t : Triple,
  lB : Assoc_list ]
    Assoc_subtype lA (dk_list.cons _ t lB)
      -->
    Assoc_cons t (Assoc_subtype (Assoc_rm lA (fst t)) lB).


Record_subtype : f : Typer ->
                 DA : Domain ->
                 DB : Domain ->
                 RA : Record f DA ->
                 RB : Record f DB ->
                 Record f DB.

(; [f : Typer, ;)
(;  DA : Domain, ;)
(;  RA : Record f DA, ;)
(;  RB : Record f domain_nil, ;)
(;  l : Label] ;)
(;     Record_subtype f DA (dk_list.nil _) RA RB l ;)
(;       --> ;)
(;     dk_fail.fail (f l). ;)

(; [f : Typer, ;)
(;  DA : Domain, ;)
(;  l : Label, ;)
(;  DB : Domain, ;)
(;  RA : Record f DA, ;)
(;  RB : Record f (domain_cons l DB)] ;)
(;     Record_subtype f DA (dk_list.cons _ l DB) RA RB ;)
(;       --> ;)
(;     (assoc_val (dk_list.cons triple (mk_triple l (f l) (RA l)) (dk_list.map label triple (l:Label => mk_triple l (f l) (RA l)) DB))). ;)

[ f : Typer,
  DA : Domain,
  RA : Record f DA,
  RB : Record f domain_nil]
    Record_subtype f DA (dk_list.nil _) RA RB --> RB.

[ f : Typer,
  DA : Domain,
  DB : Domain,
  RA : Record f DA,
  l : Label,
  RB : Record f (domain_cons l DB)]
    Record_subtype f DA (dk_list.cons _ l DB) RA RB
      -->
    (l2 : Label =>
     if_label_eq f l l2
                   (RA l)
                   (Record_subtype f DA DB RA RB l2)).
