#NAME dk_lrecords
(; Lightweight Records ;)
(; Same as dk_records but encoding partials functions as
    A -> B
   and not
    A -> option B. ;)

(; Labels are strings ;)

label : cc.uT := dk_string.string.
Label := cc.eT label.

bool := dk_bool.bool.
Bool := cc.eT bool.
istrue := b : Bool => dk_logic.eeP (dk_logic.ebP b).
Istrue := b : Bool => cc.eT (istrue b).

label_eq : Label -> Label -> Bool := dk_string.equal.
(; Axiom of correctness ;)
label_eq_rect : l1 : Label ->
                l2 : Label ->
                P : (Label -> cc.uT) ->
                Istrue (label_eq l2 l1) ->
                cc.eT (P l1) -> cc.eT (P l2).

[l : Label, P : Label -> cc.uT, H : Istrue (label_eq l l), x : cc.eT (P l)]
  label_eq_rect l l P H x --> x.

(; Dependant if with equality ;)
if_label_eq : P : (Label -> cc.uT) ->
              l1 : Label ->
              l2 : Label ->
              cc.eT (P l1) ->
              cc.eT (P l2) ->
              cc.eT (P l2)
:=
              P : (Label -> cc.uT) =>
              l1 : Label =>
              l2 : Label =>
              Heq : cc.eT (P l1) =>
              Hdiff : cc.eT (P l2) =>
              dk_bool.match
                (b : Bool =>
                   cc.Arrow (cc.Arrow (istrue b) (P l2))
                    (cc.Arrow (P l2) (P l2)))
                (H1 : (dk_logic.TrueT -> cc.eT (P l2)) =>
                 H2 : cc.eT (P l2) => H1 dk_logic.I)
                (H1 : (dk_logic.FalseT -> cc.eT (P l2)) =>
                 H2 : cc.eT (P l2) => H2)
                (label_eq l2 l1)
                (H : Istrue (label_eq l2 l1) =>
                   label_eq_rect l1 l2 P H Heq)
                Hdiff.

(; Domains are lists of labels ;)
domain := dk_list.list label.
Domain := cc.eT domain.
domain_nil := dk_list.nil label.
domain_cons := dk_list.cons label.

(; Records ;)

Typer := Label -> cc.uT.

record : f : Typer ->
         D : Domain ->
         cc.uT
 :=
         f : Typer =>
         D : Domain =>
         cc.Pi_TTT label f.

Record : f : Typer ->
         D : Domain ->
         Type
 :=
         f : Typer =>
         D : Domain =>
         l : Label ->
         cc.eT (f l).

(; Examples ;)

x : Label := dk_list.cons dk_char.char dk_char.x (dk_list.nil dk_char.char).
PointDomain : Domain := domain_cons x domain_nil.

PointTyper_aux : Bool -> cc.uT
               := b : Bool => dk_bool.ite cc.uuT b dk_nat.Nat cc.uuT.
PointTyper : Typer
 := l : Label => PointTyper_aux (label_eq l x).

Origin_aux : b : Bool -> cc.eT (PointTyper_aux b)
          := dk_bool.match PointTyper_aux dk_nat.O cc.uuT.
Origin : Record PointTyper PointDomain
      := l : Label => Origin_aux (label_eq l x).

(; From association lists ;)

triple : cc.uT.
Triple := cc.eT triple.
fst : Triple -> Label.
snd : Triple -> cc.uT.
Snd := t : Triple => cc.eT (snd t).
trd : t : Triple -> Snd t.
mk_triple : Label -> A : cc.uT -> cc.eT A -> Triple.
[ l : Label, A : cc.uT, a : cc.eT A ] fst (mk_triple l A a) --> l.
[ l : Label, A : cc.uT, a : cc.eT A ] snd (mk_triple l A a) --> A.
[ l : Label, A : cc.uT, a : cc.eT A ] trd (mk_triple l A a) --> a.

assoc_list := dk_list.list triple.
Assoc_list := cc.eT assoc_list.
Assoc_cons := dk_list.cons triple.
Assoc_nil := dk_list.nil triple.

Assoc_list_domain : Assoc_list -> Domain := dk_list.map triple label fst.

assoc_type : Assoc_list -> Label -> cc.uT.
[ l1 : Label, A : cc.uT, a : cc.eT A,
  L : Assoc_list, l2 : Label ]
    assoc_type (dk_list.cons _ (mk_triple l1 A a) L) l2 -->
          dk_bool.ite cc.uuT
            (label_eq l1 l2)
            A
            (assoc_type L l2).

assoc_val : L : Assoc_list -> l : Label -> cc.eT (assoc_type L l).
[ l1 : Label, A : cc.uT, a : cc.eT A,
  L : Assoc_list, l2 : Label ]
    assoc_val (dk_list.cons _ (mk_triple l1 A a) L) l2 -->
          dk_bool.match
            (b : Bool => dk_bool.ite cc.uuT b A (assoc_type L l2))
            a
            (assoc_val L l2)
            (label_eq l1 l2).

Assoc_list_record : L : Assoc_list ->
                    Record (assoc_type L) (Assoc_list_domain L)
                  := assoc_val.

Origin1D := Assoc_list_record
               (Assoc_cons (mk_triple x dk_nat.Nat dk_nat.O) Assoc_nil).

{ origin1D_x_is_0 } :
  dk_logic.eP (dk_logic.equal dk_nat.Nat (Origin1D x) dk_nat.O)
:=
  dk_logic.refl dk_nat.Nat dk_nat.O.

y : Label := dk_list.cons dk_char.char dk_char.y (dk_list.nil dk_char.char).

Origin2D := Assoc_list_record (Assoc_cons (mk_triple x dk_nat.Nat dk_nat.O)
                              (Assoc_cons (mk_triple y dk_nat.Nat dk_nat.O)
                               Assoc_nil)).

{ origin2D_x_is_y } :
  dk_logic.eP (dk_logic.equal dk_nat.Nat (Origin2D x) (Origin2D y))
:=
  dk_logic.refl dk_nat.Nat dk_nat.O.

c : Label := dk_list.cons dk_char.char dk_char.c (dk_list.nil dk_char.char).
color : cc.uT.
red : cc.eT color.

ColoredOrigin2D
         := Assoc_list_record (Assoc_cons (mk_triple x dk_nat.Nat dk_nat.O)
                              (Assoc_cons (mk_triple y dk_nat.Nat dk_nat.O)
                              (Assoc_cons (mk_triple c color red)
                               Assoc_nil))).

(; From association list with a fixed typer ;)

couple : Typer -> cc.uT.
Couple := f : Typer => cc.eT (couple f).
fstT : f : Typer -> Couple f -> Label.
sndT : f : Typer -> c : Couple f -> cc.eT (f (fstT f c)).
mk_couple : f : Typer -> l : Label -> cc.eT (f l) -> Couple f.
[ f : Typer, l : Label, a : cc.eT (f l) ] fstT _ (mk_couple f l a) --> l.
[ f : Typer, l : Label, a : cc.eT (f l) ] sndT _ (mk_couple f l a) --> a.

assocT_list := f : Typer => dk_list.list (couple f).
AssocT_list := f : Typer => cc.eT (assocT_list f).
AssocT_cons := f : Typer => dk_list.cons (couple f).
AssocT_nil := f : Typer => dk_list.nil (couple f).

AssocT_list_domain : f : Typer -> AssocT_list f -> Domain
:= f : Typer => dk_list.map (couple f) label (fstT f).

assocT_val : f : Typer -> L : AssocT_list f -> l : Label -> cc.eT (f l).
[ f : Typer,
  l1 : Label, a : cc.eT (f l1),
  L : AssocT_list f, l2 : Label ]
    assocT_val f (dk_list.cons _ (mk_couple _ l1 a) L) l2 -->
          if_label_eq f l1 l2
            a
            (assocT_val f L l2).

AssocT_list_record : f : Typer ->
                     L : AssocT_list f ->
                     Record f (AssocT_list_domain f L)
                     := assocT_val.

(; To association lists ;)
to_assoc_list : f : Typer ->
                D : Domain ->
                Record f D ->
                Assoc_list
:=
                f : Typer =>
                D : Domain =>
                R : Record f D =>
                dk_list.map
                  label
                  triple
                  (l : Label => mk_triple l (f l) (R l))
                  D.
