#NAME cc.
(; Calculus of Construction embedded into Lambda-Pi Modulo ;)

uT : Type.
def eT : uT -> Type.

Pi : X : uT -> ((eT X) -> uT) -> uT.
[X,Y] eT (Pi X Y) --> x : (eT X) -> (eT (Y x)).

def Arrow : uT -> uT -> uT.
[t1,t2] Arrow t1 t2 --> Pi t1 (x : eT t1 => t2).


(; Declaration of some types which need to add rules on eT. ;)

(; See dk_type ;)
(; Cartesian product ;)

(; Dependant sum ;)
Sigma : A : uT -> (eT A -> uT) -> Type.
sigma : A : uT -> (eT A -> uT) -> uT.
[X,Y] eT (sigma X Y) --> Sigma X Y.

(; Binary sum ;)
Sum : uT -> uT -> Type.
sum : uT -> uT -> uT.
[X,Y] eT (sum X Y) --> Sum X Y.

(; See dk_list ;)
(; Lists ;)
List : uT -> Type.
list : uT -> uT.
[A] eT (list A) --> List A.

(; See dk_nat ;)
Nat : Type.
nat : uT.
[] eT nat --> Nat.

(; See dk_machine_int ;)
MInt : Nat -> Type.
Mint : Nat -> uT.
[N] eT (Mint N) --> MInt N.

(; See dk_opt ;)
Option : uT -> Type.
option : uT -> uT.
[A] eT (option A) --> Option A.
